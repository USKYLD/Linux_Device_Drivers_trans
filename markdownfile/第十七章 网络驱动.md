在讨论了字符驱动和块驱动后，我们现在准备进入网络的世界。网络接口是Linux设备的第三个标准类别，本章将描述它们如何与内核的其他部分交互。

网络接口在系统中的角色类似于挂载的块设备。块设备将其磁盘和方法注册到内核，然后通过其请求函数“传输”和“接收”块。类似地，网络接口必须在特定的内核数据结构中注册自己，以便在与外部世界交换数据包时被调用。

挂载的磁盘和数据包传输接口之间有一些重要的区别。首先，磁盘存在于/dev目录的特殊文件中，而网络接口没有这样的入口点。正常的文件操作（读、写等）应用于网络接口时没有意义，所以不可能将Unix的“一切皆文件”方法应用于它们。因此，网络接口存在于它们自己的命名空间，并导出一组不同的操作。

虽然你可能会反对应用程序在使用套接字时使用read和write系统调用，但这些调用作用于一个与接口不同的软件对象。几百个套接字可以在同一个物理接口上复用。

但是两者之间最重要的区别是，块驱动只在内核的请求下操作，而网络驱动从外部异步接收数据包。因此，当块驱动被要求向内核发送一个缓冲区时，网络设备要求将传入的数据包推向内核。网络驱动的内核接口是为这种不同的操作模式设计的。

网络驱动还必须准备支持一些管理任务，如设置地址、修改传输参数和维护流量和错误统计。网络驱动的API反映了这种需求，因此，看起来与我们迄今为止看到的接口有些不同。

Linux内核的网络子系统被设计为完全协议独立。这既适用于网络协议（互联网协议[IP]与IPX或其他协议），也适用于硬件协议（以太网与令牌环等）。

网络驱动与内核之间的交互适当地处理一次一个网络数据包；这允许协议问题从驱动程序中隐藏得很好，并且从协议中隐藏物理传输。

本章描述了网络接口如何与Linux内核的其他部分配合，并提供了一个基于内存的模块化网络接口的例子，它被称为（你猜对了）snull。为了简化讨论，接口使用以太网硬件协议并传输IP数据包。你从研究snull获得的知识可以很容易地应用到IP以外的协议，编写非以太网驱动只在与实际网络协议相关的微小细节上有所不同。

本章不讨论IP编号方案、网络协议或其他一般的网络概念。这些主题通常不是驱动程序编写者关心的，而且在几百页内提供一个满意的网络技术概述是不可能的。建议感兴趣的读者参考其他描述网络问题的书籍。

在进入网络设备之前，有必要对术语做一些说明。网络世界使用术语“八位字节”来指代一组八位，这通常是网络设备和协议理解的最小单位。在这种情况下，几乎从不遇到“字节”这个术语。为了保持标准用法，我们在谈论网络设备时会使用“八位字节”。

“头部”这个术语也值得快速提及。头部是一组字节（呃，八位字节），在数据包通过网络子系统的各个层次时被添加到数据包前面。当应用程序通过TCP套接字发送一块数据时，网络子系统将这些数据分解成数据包，并在开始处放置一个TCP头部，描述每个数据包在流中的位置。然后，较低的层次在TCP头部前面放置一个IP头部，用于将数据包路由到其目的地。如果数据包在类似以太网的介质上移动，一个以太网头部，由硬件解释，会在其余部分前面。网络驱动程序通常不需要关心高级头部（通常），但它们经常必须参与硬件级头部的创建。

## 17.1. snull 是如何设计的

本节讨论了导致snull网络接口的设计概念。虽然这些信息可能看起来用处不大，但如果你不理解它，当你使用示例代码时可能会遇到问题。

第一个，也是最重要的，设计决策是示例接口应该保持独立于真实硬件，就像本书中使用的大多数示例代码一样。这个约束导致了类似于环回接口的东西。snull不是一个环回接口；然而，它模拟与真实远程主机的对话，以便更好地演示编写网络驱动程序的任务。Linux环回驱动实际上非常简单；它可以在drivers/net/loopback.c中找到。

snull的另一个特性是它只支持IP流量。这是接口内部工作的结果——snull必须查看并解释数据包，以正确地模拟一对硬件接口。真实的接口不依赖于正在传输的协议，而这个snull的限制并不影响本章中显示的代码片段。

### 17.1.1. 分配 IP 号

snull模块创建了两个接口。这些接口与简单的环回不同，因为你通过其中一个接口传输的任何东西都会回到另一个接口，而不是自身。它看起来像你有两个外部链接，但实际上你的计算机正在回应自己。

不幸的是，这种效果不能仅通过IP号码分配来实现，因为内核不会通过接口A发送一个定向到自己接口B的数据包。相反，它会使用环回通道，而不经过snull。为了能够通过snull接口建立通信，需要在数据传输过程中修改源地址和目标地址。换句话说，通过其中一个接口发送的数据包应该被另一个接口接收，但是出站数据包的接收者不应该被识别为本地主机。接收到的数据包的源地址也是如此。

为了实现这种“隐藏的环回”，snull接口切换源地址和目标地址的第三个八位组的最低有效位；也就是说，它改变了C类IP号码的网络号和主机号。最终的效果是，发送到网络A（连接到sn0，第一个接口）的数据包在sn1接口上显示为属于网络B的数据包。

为了避免处理太多的数字，让我们为涉及的IP号码分配符号名称：

-   snullnet0是连接到sn0接口的网络。同样，snullnet1是连接到sn1的网络。这些网络的地址只应在第三个八位组的最低有效位上有所不同。这些网络必须有24位的网络掩码。
-   local0是分配给sn0接口的IP地址；它属于snullnet0。与sn1关联的地址是local1。local0和local1必须在它们的第三个八位组的最低有效位和第四个八位组中有所不同。
-   remote0是snullnet0中的一个主机，它的第四个八位组与local1的相同。任何发送到remote0的数据包在其网络地址被接口代码修改后都会到达local1。主机remote1属于snullnet1，它的第四个八位组与local0的相同。

snull接口的操作在图17-1中描绘，其中每个接口关联的主机名打印在接口名附近。


![[Pasted image 20240207162428.png]]

以下是网络号码的可能值。一旦你把这些行放入`/etc/networks`，你就可以用名字来调用你的网络。这些值是从为私人使用保留的数字范围中选择的。
```c
snullnet0       192.168.0.0

snullnet1       192.168.1.0
```
以下是可能放入`/etc/hosts`的主机号码：
```c
192.168.0.1   local0

192.168.0.2   remote0

192.168.1.2   local1

192.168.1.1   remote1
```
这些数字的重要特性是，local0的主机部分与remote1的相同，local1的主机部分与remote0的相同。只要这种关系适用，你可以使用完全不同的数字。

然而，如果你的计算机已经连接到一个网络，要小心。你选择的数字可能是真正的互联网或内网数字，将它们分配给你的接口会阻止与真正的主机的通信。例如，虽然刚刚显示的数字不是可路由的互联网数字，但它们可能已经被你的私人网络使用。

无论你选择哪些数字，你都可以通过发出以下命令正确地设置接口的操作：
```c
ifconfig sn0 local0

ifconfig sn1 local1
```
如果选择的地址范围不是C类范围，你可能需要添加`netmask 255.255.255.0`参数。

此时，接口的“远程”端可以被访问。以下屏幕截图显示了主机如何通过snull接口访问remote0和remote1：
```shell
morgana% ping -c 2 remote0

64 bytes from 192.168.0.99: icmp_seq=0 ttl=64 time=1.6 ms

64 bytes from 192.168.0.99: icmp_seq=1 ttl=64 time=0.9 ms

2 packets transmitted, 2 packets received, 0% packet loss

morgana% ping -c 2 remote1

64 bytes from 192.168.1.88: icmp_seq=0 ttl=64 time=1.8 ms

64 bytes from 192.168.1.88: icmp_seq=1 ttl=64 time=0.9 ms

2 packets transmitted, 2 packets received, 0% packet loss
```
注意，你将无法访问属于这两个网络的任何其他“主机”，因为在地址被修改并且数据包被接收后，你的计算机会丢弃这些数据包。例如，一个目标为192.168.0.32的数据包将通过sn0离开，并在sn1处以192.168.1.32的目标地址重新出现，这不是主机计算机的本地地址。

### 17.1.2. 报文的物理传送
就数据传输而言，snull接口属于以太网类。snull模拟以太网，因为绝大多数现有的网络——至少工作站连接到的部分——都基于以太网技术，无论是10base-T、100base-T还是千兆以太网。此外，内核为以太网设备提供了一些通用支持，没有理由不使用它。作为以太网设备的优势如此强大，以至于即使是plip接口（使用打印机端口的接口）也声明自己是以太网设备。

使用以太网设置snull的最后一个优点是，你可以在接口上运行tcpdump来查看数据包的传输情况。使用tcpdump观察接口可以是了解两个接口如何工作的一种有用方式。

如前所述，snull只能处理IP数据包。这个限制是由于snull会窥探数据包甚至修改它们，以使代码能够工作。代码修改每个数据包的IP头部的源、目标和校验和，而不检查它是否实际传输IP信息。这种快速而肮脏的数据修改会破坏非IP数据包。如果你想通过snull传送其他协议，你必须修改模块的源代码。


## 17.2. 连接到内核
我们通过解析snull源代码来开始查看网络驱动程序的结构。手头准备好几个驱动程序的源代码可能会帮助你跟随讨论，并看到现实世界中的Linux网络驱动程序是如何操作的。作为开始，我们建议从loopback.c、plip.c和e100.c开始，它们的复杂性逐渐增加。所有这些文件都位于内核源代码树中的drivers/net目录下。

- 以下是一些基本的步骤来开始理解网络驱动程序的结构：

1.  打开你的Linux内核源代码目录，并导航到drivers/net。
    
2.  打开loopback.c文件。这是最简单的网络驱动程序，它实现了本地回环设备。尝试理解这个文件中的代码。
    
3.  接下来，打开plip.c文件。这个驱动程序实现了通过并行端口进行网络通信的功能。它比loopback.c更复杂一些，但仍然相对简单。
    
4.  最后，打开e100.c文件。这是一个完整的以太网驱动程序，用于Intel的e100网络接口卡。这个文件的代码比前两个文件更复杂，但它提供了一个很好的例子，展示了一个完整的网络驱动程序是如何工作的。
    

通过阅读和理解这些文件，你可以开始理解Linux网络驱动程序的基本结构和工作原理。


### 17.2.1. 设备注册
当驱动模块被加载到正在运行的内核中时，它会请求资源并提供设施；这并不新鲜。同样，请求资源的方式也没有什么新鲜的。驱动应该探测其设备和硬件位置（I/O端口和IRQ线）——但不注册它们——如第10章的“安装中断处理程序”中所述。网络驱动程序由其模块初始化函数注册的方式与字符和块驱动程序不同。由于网络接口没有等同于主要和次要数字的东西，网络驱动程序不请求这样的数字。相反，驱动程序将每个新检测到的接口的数据结构插入到网络设备的全局列表中。

每个接口由一个`struct net_device`项描述，该项在`<linux/netdevice.h>`中定义。snull驱动程序在一个简单的数组中保持对这些结构的两个指针（对于sn0和sn1）：
```c
struct net_device *snull_devs[2];
```
`net_device`结构，像许多其他内核结构一样，包含一个`kobject`，因此，它是引用计数的，并通过`sysfs`导出。与其他这样的结构一样，它必须动态分配。提供执行此分配的内核函数是`alloc_netdev`，其原型如下：
```c
struct net_device *alloc_netdev(int sizeof_priv,

                                const char *name,

                                void (*setup)(struct net_device *));
```
这里，`sizeof_priv`是驱动程序的“私有数据”区域的大小；对于网络设备，该区域与`net_device`结构一起分配。实际上，这两者在一个大的内存块中一起分配，但驱动程序作者应该假装他们不知道这一点。`name`是用户空间看到的此接口的名称；此名称可以有一个printf风格的`%d`。内核用下一个可用的接口号替换`%d`。最后，`setup`是一个指向初始化函数的指针，该函数被调用以设置`net_device`结构的其余部分。我们马上就要到初始化函数，但现在，只需说snull以这种方式分配其两个设备结构：
```c
snull_devs[0] = alloc_netdev(sizeof(struct snull_priv), "sn%d",

        snull_init);

snull_devs[1] = alloc_netdev(sizeof(struct snull_priv), "sn%d",

        snull_init);

if (snull_devs[0] == NULL || snull_devs[1] == NULL)

    goto out;
```
像往常一样，我们必须检查返回值以确保分配成功。

网络子系统提供了一些围绕`alloc_netdev`的辅助函数，用于各种类型的接口。最常见的是`alloc_etherdev`，在`<linux/etherdevice.h>`中定义：
```c
struct net_device *alloc_etherdev(int sizeof_priv);
```
此函数使用`eth%d`作为名称参数来分配网络设备。它提供了自己的初始化函数（`ether_setup`），该函数使用适合以太网设备的适当值设置了几个`net_device`字段。因此，`alloc_etherdev`没有驱动程序提供的初始化函数；驱动程序应该在成功分配后直接进行所需的初始化。其他类型设备的驱动程序编写者可能希望利用其他辅助函数，如`alloc_fcdev`（在`<linux/fcdevice.h>`中定义）用于光纤通道设备，`alloc_fddidev`（`<linux/fddidevice.h>`）用于FDDI设备，或`alloc_trdev`（`<linux/trdevice.h>`）用于令牌环设备。

snull可以毫无问题地使用`alloc_etherdev`；我们选择使用`alloc_netdev`，作为演示低级接口的一种方式，并让我们控制分配给接口的名称。

一旦`net_device`结构被初始化，完成过程只是将结构传递给`register_netdev`的问题。在snull中，调用如下所示：
```c
for (i = 0; i < 2;  i++)

    if ((result = register_netdev(snull_devs[i])))

        printk("snull: error %i registering device \"%s\"\n",

                result, snull_devs[i]->name);
```
这里应用了通常的警告：一旦你调用`register_netdev`，你的驱动程序可能会被调用来操作设备。因此，你不应该在所有东西完全初始化之前注册设备。

### 17.2.2. 初始化每一个设备
我们已经查看了`net_device`结构的分配和注册，但我们跳过了完全初始化该结构的中间步骤。注意，`struct net_device`总是在运行时组装的；它不能像`file_operations`或`block_device_operations`结构那样在编译时设置。这个初始化必须在调用`register_netdev`之前完成。`net_device`结构是大而复杂的；幸运的是，内核通过`ether_setup`函数（由`alloc_etherdev`调用）处理了一些以太网的默认设置。由于snull使用`alloc_netdev`，它有一个单独的初始化函数。这个函数（`snull_init`）的核心如下：
```c
ether_setup(dev); /* assign some of the fields */

dev->open            = snull_open;

dev->stop            = snull_release;

dev->set_config      = snull_config;

dev->hard_start_xmit = snull_tx;

dev->do_ioctl        = snull_ioctl;

dev->get_stats       = snull_stats;

dev->rebuild_header  = snull_rebuild_header;

dev->hard_header     = snull_header;

dev->tx_timeout      = snull_tx_timeout;

dev->watchdog_timeo = timeout;

/* keep the default flags, just add NOARP */

dev->flags           |= IFF_NOARP;

dev->features        |= NETIF_F_NO_CSUM;

dev->hard_header_cache = NULL;      /* Disable caching */
```
上述代码是对`net_device`结构的相当常规的初始化；它主要是存储我们各种驱动程序函数的指针。代码的唯一不寻常的特性是在标志中设置`IFF_NOARP`。这指定接口不能使用地址解析协议（ARP）。ARP是一个低级以太网协议；它的工作是将IP地址转换为以太网媒体访问控制（MAC）地址。由于snull模拟的“远程”系统实际上并不存在，所以没有人可以回答它们的ARP请求。我们选择将接口标记为无法处理该协议，而不是通过添加ARP实现来复杂化snull。对`hard_header_cache`的赋值也是出于类似的原因：它禁用了在此接口上缓存（不存在的）ARP回复。这个主题在本章后面的“MAC地址解析”部分详细讨论。

初始化代码还设置了一对与处理传输超时相关的字段（`tx_timeout`和`watchdog_timeo`）。我们在“传输超时”部分详细介绍了这个主题。

我们现在看一下另一个`struct net_device`字段，`priv`。它的角色类似于我们用于字符驱动程序的`private_data`指针。与`fops->private_data`不同，这个`priv`指针是与`net_device`结构一起分配的。出于性能和灵活性的原因，也不鼓励直接访问`priv`字段。当驱动程序需要获取私有数据指针的访问权限时，它应该使用`netdev_priv`函数。因此，snull驱动程序充满了如下声明：
```c
struct snull_priv *priv = netdev_priv(dev);

snull模块声明了一个用于`priv`的`snull_priv`数据结构：

struct snull_priv {

    struct net_device_stats stats;

    int status;

    struct snull_packet *ppool;

    struct snull_packet *rx_queue;  /* List of incoming packets */

    int rx_int_enabled;

    int tx_packetlen;

    u8 *tx_packetdata;

    struct sk_buff *skb;

    spinlock_t lock;

};
```
该结构包括了其他一些内容，其中一个实例是`struct net_device_stats`，这是保存接口统计信息的标准位置。在`snull_init`中的以下行分配并初始化`dev->priv`：
```c
priv = netdev_priv(dev);

memset(priv, 0, sizeof(struct snull_priv));

spin_lock_init(&priv->lock);

snull_rx_ints(dev, 1);      /* enable receive interrupts */
```

### 17.2.3. 模块卸载
当模块被卸载时，没有什么特别的事情发生。模块清理函数只是注销接口，执行所需的内部清理，并将`net_device`结构返回给系统：
```c
void snull_cleanup(void)

{

    int i;

    for (i = 0; i < 2;  i++) {

        if (snull_devs[i]) {

            unregister_netdev(snull_devs[i]);

            snull_teardown_pool(snull_devs[i]);

            free_netdev(snull_devs[i]);

        }

    }

    return;

}
```
调用`unregister_netdev`从系统中移除接口；`free_netdev`将`net_device`结构返回给内核。如果某处存在对该结构的引用，它可能会继续存在，但你的驱动程序不需要关心这个。一旦你注销了接口，内核就不再调用它的方法。

注意，我们的内部清理（在`snull_teardown_pool`中完成）不能在设备被注销之前发生。然而，它必须在我们将`net_device`结构返回给系统之前发生；一旦我们调用了`free_netdev`，我们就不能再对设备或我们的私有区域进行任何进一步的引用。



## 17.3. net_device 结构体的详情

`net_device`结构是网络驱动层的核心，值得完整的描述。这个列表描述了所有的字段，但更多的是提供一个参考，而不是要记住。本章的其余部分在示例代码中使用每个字段时都会简要描述，所以你不需要不断地回到这一节。

由于你没有提供具体的问题或请求，我无法提供更多的帮助。如果你有关于`net_device`结构的具体问题或者需要关于如何在代码中使用它的帮助，欢迎提问。


### 17.3.1. 全局信息
`struct net_device`的第一部分由以下字段组成：
```c
char name[IFNAMSIZ];
```
设备的名称。如果驱动程序设置的名称包含一个`%d`格式字符串，`register_netdev`会用一个数字替换它，以生成一个唯一的名称；分配的数字从0开始。
```c
unsigned long state;
```
设备状态。该字段包括几个标志。驱动程序通常不直接操作这些标志；相反，提供了一组实用函数。当我们进入驱动程序操作时，将讨论这些函数。
```c
struct net_device *next;
```
指向全局链表中的下一个设备的指针。驱动程序不应触摸这个字段。
```c
int (*init)(struct net_device *dev);
```
一个初始化函数。如果设置了这个指针，`register_netdev`会调用这个函数来完成`net_device`结构的初始化。大多数现代网络驱动程序不再使用这个函数；相反，接口注册之前就进行了初始化。



### 17.3.2. 硬件信息
以下字段包含了相对简单设备的低级硬件信息。它们是Linux网络早期的遗留物；大多数现代驱动程序不使用它们（可能的例外是`if_port`）。我们在这里列出它们以便完整性。
```c
unsigned long rmem_end;

unsigned long rmem_start;

unsigned long mem_end;

unsigned long mem_start;
```
设备内存信息。这些字段保存设备使用的共享内存的开始和结束地址。如果设备有不同的接收和发送内存，`mem`字段用于发送内存，`rmem`字段用于接收内存。`rmem`字段从未在驱动程序本身之外被引用。按照惯例，`end`字段被设置为`end - start`是可用的板载内存的数量。
```c
unsigned long base_addr;
```
网络接口的I/O基地址。这个字段，像前面的字段一样，是在设备探测期间由驱动程序分配的。`ifconfig`命令可以用来显示或修改当前值。`base_addr`可以在系统启动时在内核命令行上显式分配（通过`netdev=`参数）或在模块加载时分配。这个字段，像上面描述的内存字段一样，不被内核使用。
```c
unsigned char irq;
```
分配的中断号。`dev->irq`的值在列出接口时由`ifconfig`打印。这个值通常可以在启动或加载时设置，并可以稍后使用`ifconfig`修改。
```c
unsigned char if_port;
```
在多端口设备上使用的端口。例如，这个字段用于支持同轴（`IF_PORT_10BASE2`）和双绞线（`IF_PORT_100BASET`）以太网连接的设备。在`<linux/netdevice.h>`中定义了已知的端口类型的完整集合。
```c
unsigned char dma;
```
设备分配的DMA通道。这个字段只对一些外设总线有意义，比如ISA。它不在设备驱动程序本身之外使用，但用于信息目的（在`ifconfig`中）。



### 17.3.3. 接口信息
接口的大部分信息都被`ether_setup`函数（或者其他适合给定硬件类型的设置函数）正确地设置了。以太网卡可以依赖这个通用函数来设置这些字段的大部分，但是`flags`和`dev_addr`字段是设备特定的，必须在初始化时显式分配。

一些非以太网接口可以使用类似于`ether_setup`的辅助函数。`drivers/net/net_init.c`导出了一些这样的函数，包括以下几个：
```c
void ltalk_setup(struct net_device *dev);
```
为LocalTalk设备设置字段
```c
void fc_setup(struct net_device *dev);
```
为光纤通道设备初始化字段
```c
void fddi_setup(struct net_device *dev);
```
为Fiber Distributed Data Interface (FDDI)网络配置接口
```c
void hippi_setup(struct net_device *dev);
```
为High-Performance Parallel Interface (HIPPI)高速互连驱动程序准备字段
```c
void tr_setup(struct net_device *dev);
```
处理令牌环网络接口的设置

大多数设备都被这些类别覆盖。然而，如果你的设备是完全新的和不同的，你需要手动分配以下字段：
```c
unsigned short hard_header_len;
```
硬件头长度，即在IP头或其他协议信息之前引导传输包的字节数。对于以太网接口，`hard_header_len`的值是14（`ETH_HLEN`）。
```c
unsigned mtu;
```
最大传输单元（MTU）。这个字段被网络层用来驱动包传输。以太网的MTU是1500字节（`ETH_DATA_LEN`）。这个值可以用`ifconfig`改变。
```c
unsigned long tx_queue_len;
```
设备的传输队列上可以排队的最大帧数。这个值被`ether_setup`设置为1000，但你可以改变它。例如，`plip`使用10来避免浪费系统内存（`plip`的吞吐量比真正的以太网接口低）。
```c
unsigned short type;
```
接口的硬件类型。`type`字段被ARP用来确定接口支持什么类型的硬件地址。对于以太网接口，适当的值是`ARPHRD_ETHER`，这是`ether_setup`设置的值。在`<linux/if_arp.h>`中定义了认可的类型。
```c
unsigned char addr_len;

unsigned char broadcast[MAX_ADDR_LEN];

unsigned char dev_addr[MAX_ADDR_LEN];
```
硬件（MAC）地址长度和设备硬件地址。以太网地址长度是六个字节（我们指的是接口板的硬件ID），广播地址由六个0xff字节组成；`ether_setup`安排这些值是正确的。另一方面，设备地址必须以设备特定的方式从接口板中读取，驱动程序应将其复制到`dev_addr`。硬件地址用于在将包交给驱动程序进行传输之前生成正确的以太网头。`snull`设备不使用物理接口，它发明了自己的硬件地址。
```c
unsigned short flags;

int features;
```

接口标志（接下来详细介绍）。

`flags`字段是一个位掩码，包括以下位值。`IFF_`前缀代表“接口标志”。一些标志由内核管理，一些在初始化时由接口设置，以断言接口的各种能力和其他特性。有效的标志在`<linux/if.h>`中定义，包括：
```c
IFF_UP
```
此标志对驱动程序是只读的。当接口处于活动状态并准备传输包时，内核会打开它。
```c
IFF_BROADCAST
```
此标志（由网络代码维护）表示接口允许广播。以太网板可以。
```c
IFF_DEBUG
```
这标志了调试模式。该标志可以用来控制你的`printk`调用的详细程度或用于其他调试目的。虽然没有在树中的驱动程序当前使用此标志，但它可以通过`ioctl`由用户程序设置和重置，你的驱动程序可以使用它。`misc-progs/netifdebug`程序可以用来打开和关闭该标志。
```c
IFF_LOOPBACK
```
此标志只应在回环接口中设置。内核检查`IFF_LOOPBACK`，而不是将`lo`名称硬编码为特殊接口。
```c
IFF_POINTOPOINT
```
此标志表示接口连接到点对点链接。它由驱动程序设置，或者有时由`ifconfig`设置。例如，`plip`和PPP驱动程序已设置。
```c
IFF_NOARP
```
这意味着接口不能执行ARP。例如，点对点接口不需要运行ARP，这只会增加额外的流量，而不会检索有用的信息。`snull`在没有ARP能力的情况下运行，所以它设置了该标志。
```c
IFF_PROMISC
```
此标志由网络代码设置，以激活混杂操作。默认情况下，以太网接口使用硬件过滤器，以确保它们只接收广播包和定向到该接口的硬件地址的包。像`tcpdump`这样的包嗅探器在接口上设置混杂模式，以检索在接口的传输介质上旅行的所有包。
```c
IFF_MULTICAST
```
驱动程序设置此标志，以标记能够进行多播传输的接口。`ether_setup`默认设置`IFF_MULTICAST`，所以如果你的驱动程序不支持多播，它必须在初始化时清除该标志。
```c
IFF_ALLMULTI
```
此标志告诉接口接收所有多播包。当主机执行多播路由时，只有在设置了`IFF_MULTICAST`的情况下，内核才会设置它。`IFF_ALLMULTI`对驱动程序是只读的。在本章后面的“多播”部分使用了多播标志。
```c
IFF_MASTER

IFF_SLAVE
```
这些标志由负载均衡代码使用。接口驱动程序不需要知道它们。
```c
IFF_PORTSEL

IFF_AUTOMEDIA
```
这些标志表示设备能够在多种媒体类型之间切换；例如，非屏蔽双绞线（UTP）与同轴以太网电缆。如果设置了`IFF_AUTOMEDIA`，设备会自动选择适当的媒体。实际上，内核对这两个标志都没有使用。
```c
IFF_DYNAMIC
```
此标志由驱动程序设置，表示此接口的地址可以更改。它目前没有被内核使用。
```c
IFF_RUNNING
```
此标志表示接口正在运行。它主要存在于BSD兼容性；内核很少使用它。大多数网络驱动程序不需要担心`IFF_RUNNING`。
```c
IFF_NOTRAILERS
```
此标志在Linux中未使用，但它存在于BSD兼容性。

当程序更改`IFF_UP`时，将调用打开或停止设备方法。此外，当修改`IFF_UP`或任何其他标志时，将调用`set_multicast_list`方法。如果驱动程序需要对标志的修改做出一些响应，它必须在`set_multicast_list`中执行该操作。例如，当设置或重置`IFF_PROMISC`时，`set_multicast_list`必须通知板载硬件过滤器。这个设备方法的职责在“多播”部分有所概述。

`net_device`结构的`features`字段由驱动程序设置，以告诉内核此接口具有的任何特殊硬件能力。我们将讨论其中的一些特性；其他的超出了本书的范围。完整的集合是：
```c
NETIF_F_SG

NETIF_F_FRAGLIST
```
这两个标志都控制散列/聚集I/O的使用。如果你的接口可以传输已分割成几个不同的内存段的包，你应该设置`NETIF_F_SG`。当然，你必须实际实现散列/聚集I/O（我们在“散列/聚集I/O”部分描述了如何做到这一点）。`NETIF_F_FRAGLIST`表示你的接口可以处理已经被分片的包；只有在2.6中的回环驱动程序这样做。

注意，如果你的设备不提供某种形式的校验和，内核不会对你的设备执行散列/聚集I/O。原因是，如果内核必须对一个分片的（“非线性的”）包进行一次传递以计算校验和，那么它也可以在同一时间复制数据并合并包。
```c
NETIF_F_IP_CSUM

NETIF_F_NO_CSUM

NETIF_F_HW_CSUM
```
这些标志都是告诉内核，它不需要对通过此接口离开系统的部分或所有包应用校验和。如果你的接口可以校验IP包，但不能校验其他包，设置`NETIF_F_IP_CSUM`。如果此接口永远不需要校验和，设置`NETIF_F_NO_CSUM`。回环驱动程序设置了这个标志，`snull`也设置了；因为包只是通过系统内存传输，所以（希望！）它们没有被破坏的机会，也不需要检查它们。如果你的硬件自己做校验和，设置`NETIF_F_HW_CSUM`。
```c
NETIF_F_HIGHDMA
```
如果你的设备可以对高内存执行DMA，设置此标志。在没有此标志的情况下，提供给你的驱动程序的所有包缓冲区都在低内存中分配。
```c
NETIF_F_HW_VLAN_TX

NETIF_F_HW_VLAN_RX

NETIF_F_HW_VLAN_FILTER

NETIF_F_VLAN_CHALLENGED
```
这些选项描述了你的硬件对802.1q VLAN包的支持。VLAN支持超出了我们在本章中可以覆盖的内容。如果VLAN包混淆了你的设备（它们真的不应该），设置`NETIF_F_VLAN_CHALLENGED`标志。
```c
NETIF_F_TSO
```
如果你的设备可以执行TCP分段卸载，设置此标志。TSO是我们在这里无法覆盖的高级特性。

### 17.3.4. 设备方法
与字符和块驱动程序一样，每个网络设备都声明了对其进行操作的函数。可以在网络接口上执行的操作在本节中列出。一些操作可以留空，其他操作通常不会被触动，因为`ether_setup`为它们分配了合适的方法。

网络接口的设备方法可以分为两组：基本和可选。基本方法包括那些需要使用接口的方法；可选方法实现了不是严格要求的更高级的功能。以下是基本方法：
```c
int (*open)(struct net_device *dev);
```
打开接口。每当`ifconfig`激活它时，接口就会打开。`open`方法应注册它需要的任何系统资源（I/O端口，IRQ，DMA等），打开硬件，并执行设备需要的任何其他设置。
```c
int (*stop)(struct net_device *dev);
```
停止接口。当接口被关闭时，接口就会停止。这个函数应该反转在打开时执行的操作。
```c
int (*hard_start_xmit) (struct sk_buff *skb, struct net_device *dev);
```
启动包传输的方法。完整的包（协议头和所有内容）包含在一个套接字缓冲区（`sk_buff`）结构中。套接字缓冲区在本章后面介绍。
```c
int (*hard_header) (struct sk_buff *skb, struct net_device *dev, unsigned short type, void *daddr, void *saddr, unsigned len);
```
函数（在`hard_start_xmit`之前调用）从之前检索的源和目标硬件地址构建硬件头；它的工作是将作为参数传递给它的信息组织成一个适当的，特定于设备的硬件头。`eth_header`是以太网类接口的默认函数，`ether_setup`相应地分配了这个字段。
```c
int (*rebuild_header)(struct sk_buff *skb);
```
在ARP解析完成后但在传输包之前用于重建硬件头的函数。以太网设备使用的默认函数使用ARP支持代码来填充包中缺失的信息。
```c
void (*tx_timeout)(struct net_device *dev);
```
当包传输未能在合理的时间内完成时，网络代码调用的方法，假设中断已经被错过或接口已经锁定。它应该处理问题并恢复包传输。
```c
struct net_device_stats *(*get_stats)(struct net_device *dev);
```
每当应用程序需要获取接口的统计信息时，就会调用这个方法。例如，当运行`ifconfig`或`netstat -i`时就会发生这种情况。在“统计信息”部分介绍了`snull`的一个示例实现。
```c
int (*set_config)(struct net_device *dev, struct ifmap *map);
```
更改接口配置。这个方法是配置驱动程序的入口点。设备的I/O地址和其中断号可以使用`set_config`在运行时更改。如果接口不能被探测到，系统管理员可以使用这个功能。现代硬件的驱动程序通常不需要实现这个方法。

剩余的设备操作是可选的：
```c
int weight;

int (*poll)(struct net_device *dev; int *quota);
```
由NAPI兼容驱动程序提供的方法，以轮询模式操作接口，禁用中断。NAPI（和`weight`字段）在“接收中断缓解”部分有介绍。
```c
void (*poll_controller)(struct net_device *dev);
```
函数要求驱动程序在中断被禁用的情况下检查接口上的事件。它用于特定的内核网络任务，如远程控制台和网络上的内核调试。
```c
int (*do_ioctl)(struct net_device *dev, struct ifreq *ifr, int cmd);
```
执行特定于接口的ioctl命令。（这些命令的实现在“自定义ioctl命令”部分有描述。）如果接口不需要任何特定于接口的命令，`struct net_device`中的相应字段可以设为NULL。
```c
void (*set_multicast_list)(struct net_device *dev);
```
当设备的多播列表发生变化和标志发生变化时调用的方法。有关更多详细信息和一个示例实现，请参见“多播”部分。
```c
int (*set_mac_address)(struct net_device *dev, void *addr);
```
如果接口支持更改其硬件地址的能力，可以实现的函数。许多接口根本不支持这个能力。其他接口使用默认的`eth_mac_addr`实现（来自`drivers/net/net_init.c`）。`eth_mac_addr`只将新地址复制到`dev->dev_addr`，并且只有在接口未运行时才这样做。使用`eth_mac_addr`的驱动程序应在其`open`方法中从`dev->dev_addr`设置硬件MAC地址。
```c
int (*change_mtu)(struct net_device *dev, int new_mtu);
```
如果接口的最大传输单元（MTU）发生变化，需要采取行动的函数。如果驱动程序在用户更改MTU时需要做任何特定的事情，它应该声明自己的函数；否则，默认的做法就是正确的。如果你感兴趣，`snull`有一个函数的模板。
```c
int (*header_cache) (struct neighbour *neigh, struct hh_cache *hh);
```
`header_cache`被调用以用ARP查询的结果填充`hh_cache`结构。几乎所有的以太网类驱动程序都可以使用默认的`eth_header_cache`实现。
```c
int (*header_cache_update) (struct hh_cache *hh, struct net_device *dev, unsigned char *haddr);
```
方法更新`hh_cache`结构中的目标地址以响应更改。以太网设备使用`eth_header_cache_update`。
```c
int (*hard_header_parse) (struct sk_buff *skb, unsigned char *haddr);
```
`hard_header_parse`方法从`skb`中包含的包中提取源地址，将其复制到`haddr`处的缓冲区。函数的返回值是该地址的长度。以太网设备通常使用`eth_header_parse`。



### 17.3.5. 公用成员
剩余的`struct net_device`数据字段由接口用来保存有用的状态信息。一些字段被`ifconfig`和`netstat`用来向用户提供关于当前配置的信息。因此，接口应该为这些字段赋值：
```c
unsigned long trans_start;

unsigned long last_rx;
```
这些字段保存一个`jiffies`值。驱动程序负责在传输开始和接收到数据包时更新这些值。网络子系统使用`trans_start`值来检测发送器锁定。`last_rx`目前未使用，但驱动程序应该维护这个字段，以备将来使用。
```c
int watchdog_timeo;
```
在网络层决定发生了传输超时并调用驱动程序的`tx_timeout`函数之前，应该经过的最小时间（以`jiffies`为单位）。
```c
void *priv;
```
等同于`filp->private_data`。在现代驱动程序中，这个字段由`alloc_netdev`设置，不应直接访问；应使用`netdev_priv`。
```c
struct dev_mc_list *mc_list;

int mc_count;
```
处理多播传输的字段。`mc_count`是`mc_list`中的项目数。有关更多详细信息，请参见“多播”部分。
```c
spinlock_t xmit_lock;

int xmit_lock_owner;
```
`xmit_lock`用于避免对驱动程序的`hard_start_xmit`函数的多次同时调用。`xmit_lock_owner`是获得`xmit_lock`的CPU的编号。驱动程序不应该改变这些字段。

`struct net_device`中还有其他字段，但它们不被网络驱动程序使用。



## 17.4. 打开与关闭
我们的驱动程序可以在模块加载时或内核启动时探测接口。然而，在接口可以传输数据包之前，内核必须打开它并为它分配一个地址。内核根据`ifconfig`命令来打开或关闭接口。

当`ifconfig`用来为接口分配地址时，它执行两个任务。首先，它通过`ioctl(SIOCSIFADDR)`（Socket I/O Control Set Interface Address）分配地址。然后，它通过`ioctl(SIOCSIFFLAGS)`（Socket I/O Control Set Interface Flags）在`dev->flag`中设置`IFF_UP`位，以打开接口。

就设备而言，`ioctl(SIOCSIFADDR)`什么也没做。没有驱动程序函数被调用——这个任务是设备无关的，由内核执行。然而，后一个命令（`ioctl(SIOCSIFFLAGS)`）调用了设备的`open`方法。同样，当接口被关闭时，`ifconfig`使用`ioctl(SIOCSIFFLAGS)`清除`IFF_UP`，并调用`stop`方法。

两个设备方法在成功时返回0，在出错时返回常见的负值。

就实际代码而言，驱动程序必须执行许多与字符和块驱动程序相同的任务。`open`请求它需要的任何系统资源，并告诉接口启动；`stop`关闭接口并释放系统资源。然而，网络驱动程序在打开时必须执行一些额外的步骤。

首先，硬件（MAC）地址需要在接口与外界通信之前从硬件设备复制到`dev->dev_addr`。然后，硬件地址可以在打开时复制到设备。`snull`软件接口在`open`内部分配它；它只是使用长度为`ETH_ALEN`的ASCII字符串伪造一个硬件号，`ETH_ALEN`是以太网硬件地址的长度。

`open`方法还应该启动接口的传输队列（允许它接受传输的数据包），一旦它准备好开始发送数据。内核提供了一个函数来启动队列：
```c
void netif_start_queue(struct net_device *dev);
```
`snull`的`open`代码如下：
```c
int snull_open(struct net_device *dev)

{

    /* request_region( ), request_irq( ), ....  (like fops->open) */

    /*

     * Assign the hardware address of the board: use "\0SNULx", where

     * x is 0 or 1. The first byte is '\0' to avoid being a multicast

     * address (the first byte of multicast addrs is odd).

     */

    memcpy(dev->dev_addr, "\0SNUL0", ETH_ALEN);

    if (dev == snull_devs[1])

        dev->dev_addr[ETH_ALEN-1]++; /* \0SNUL1 */

    netif_start_queue(dev);

    return 0;

}
```
如你所见，在没有真实硬件的情况下，`open`方法中要做的事情很少。`stop`方法也是如此；它只是反转`open`的操作。因此，实现`stop`的函数通常被称为`close`或`release`。
```c
int snull_release(struct net_device *dev)

{

    /* release ports, irq and such -- like fops->close */

    netif_stop_queue(dev); /* can't transmit any more */

    return 0;

}
```
函数：
```c
void netif_stop_queue(struct net_device *dev);
```
是`netif_start_queue`的反面；它将设备标记为无法传输更多的数据包。当接口关闭（在`stop`方法中）时，必须调用此函数，但也可以用来暂时停止传输，如下一节所解释的。



## 17.5. 报文传送
网络接口执行的最重要的任务是数据传输和接收。我们从传输开始，因为它稍微容易理解一些。传输是指通过网络链路发送数据包的行为。每当内核需要传输数据包时，它会调用驱动程序的`hard_start_xmit`方法，将数据放在一个出站队列上。内核处理的每个数据包都包含在一个套接字缓冲区结构（`struct sk_buff`）中，其定义在`<linux/skbuff.h>`中找到。该结构的名称来自用于表示网络连接的Unix抽象，即套接字。即使接口与套接字无关，每个网络数据包在更高的网络层都属于一个套接字，任何套接字的输入/输出缓冲区都是`struct sk_buff`结构的列表。同样的`sk_buff`结构被用来在所有的Linux网络子系统中承载网络数据，但对于接口来说，一个套接字缓冲区只是一个数据包。

通常，指向`sk_buff`的指针被称为`skb`，我们在示例代码和文本中都遵循这个惯例。

套接字缓冲区是一个复杂的结构，内核提供了一些函数来操作它。这些函数在后面的“套接字缓冲区”部分中描述；现在，关于`sk_buff`的一些基本事实对我们编写一个工作驱动程序来说已经足够了。

传递给`hard_start_xmit`的套接字缓冲区包含了应该出现在媒体上的物理数据包，包括传输级别的头部。接口不需要修改正在传输的数据。`skb->data`指向正在传输的数据包，`skb->len`是它的长度（以八位字节为单位）。如果你的驱动程序可以处理散列/聚集I/O，这种情况会变得稍微复杂一些；我们在“散列/聚集I/O”部分中讨论这个问题。

以下是`snull`数据包传输代码；物理传输机制已经被隔离在另一个函数中，因为每个接口驱动程序必须根据驱动的具体硬件来实现它：
```c
int snull_tx(struct sk_buff *skb, struct net_device *dev)

{

    int len;

    char *data, shortpkt[ETH_ZLEN];

    struct snull_priv *priv = netdev_priv(dev);

    data = skb->data;

    len = skb->len;

    if (len < ETH_ZLEN) {

        memset(shortpkt, 0, ETH_ZLEN);

        memcpy(shortpkt, skb->data, skb->len);

        len = ETH_ZLEN;

        data = shortpkt;

    }

    dev->trans_start = jiffies; /* save the timestamp */

    /* Remember the skb, so we can free it at interrupt time */

    priv->skb = skb;

    /* actual deliver of data is device-specific, and not shown here */

    snull_hw_tx(data, len, dev);

    return 0; /* Our simple device can not fail */

}
```
因此，传输函数只是对数据包进行一些完整性检查，并通过硬件相关函数传输数据。然而，请注意，当要传输的数据包比底层媒体支持的最小长度（对于`snull`，是我们的虚拟“以太网”）短时，需要特别小心。许多Linux网络驱动程序（以及其他操作系统的驱动程序）在这种情况下被发现会泄露数据。我们将短数据包复制到一个单独的数组中，我们可以明确地将其零填充到媒体所需的完整长度，而不是创建这种类型的安全漏洞。（我们可以安全地将这些数据放在栈上，因为最小长度——60字节——非常小）。

`hard_start_xmit`的返回值应该在成功时为0；此时，你的驱动程序已经对数据包负责，应该尽最大努力确保传输成功，并且必须在最后释放`skb`。非零的返回值表示此时无法传输数据包；内核稍后会重试。在这种情况下，你的驱动程序应该停止队列，直到导致失败的任何情况都已解决。

这里省略了“硬件相关”的传输函数（`snull_hw_tx`），因为它完全被用于实现`snull`设备的技巧，包括操作源地址和目标地址，对于真正的网络驱动程序的作者来说，它的内容并不感兴趣。当然，对于那些想要深入了解它是如何工作的人来说，它在示例源代码中是存在的。

### 17.5.1. 控制发送并发

`hard_start_xmit`函数通过`net_device`结构中的一个自旋锁（`xmit_lock`）来防止并发调用。然而，一旦函数返回，它可能会被再次调用。函数返回时，软件已经完成了关于数据包传输的硬件指令，但硬件传输可能还没有完成。这对`snull`来说不是问题，因为它使用CPU完成所有的工作，所以在传输函数返回之前，数据包传输就已经完成了。另一方面，真正的硬件接口异步地传输数据包，并且有限的内存可用于存储出站数据包。当这部分内存耗尽时（对于一些硬件，只需要一个待传输的数据包就会发生这种情况），驱动程序需要告诉网络系统，在硬件准备好接受新数据之前，不要开始任何更多的传输。

这个通知是通过调用`netif_stop_queue`来完成的，这是之前介绍过的用于停止队列的函数。一旦你的驱动程序停止了它的队列，它必须安排在未来的某个时候重新启动队列，当它再次能够接受传输数据包时。为此，它应该调用：
```c
void netif_wake_queue(struct net_device *dev);
```
这个函数就像`netif_start_queue`，除了它还会触发网络系统，使它开始再次传输数据包。

大多数现代网络硬件都维护一个内部队列，用于传输多个数据包；通过这种方式，它可以从网络中获得最佳性能。这些设备的网络驱动程序必须支持在任何给定时间都有多个传输在进行，但无论硬件是否支持多个待处理的传输，设备内存都可能会填满。每当设备内存填满到没有空间存放最大可能的数据包时，驱动程序应该停止队列，直到空间再次可用。

如果你必须从你的`hard_start_xmit`函数之外的任何地方禁用数据包传输（可能是响应重新配置请求），你想要使用的函数是：
```c
void netif_tx_disable(struct net_device *dev);
```
这个函数的行为很像`netif_stop_queue`，但它还确保了，当它返回时，你的`hard_start_xmit`方法不在另一个CPU上运行。队列可以像往常一样使用`netif_wake_queue`来重新启动。



### 17.5.2. 传送超时
处理真实硬件的大多数驱动程序必须准备好应对硬件偶尔无法响应的情况。接口可能会忘记它们正在做什么，或者系统可能会丢失一个中断。这种问题在一些设计用于个人电脑的设备中很常见。

许多驱动程序通过设置定时器来处理这个问题；如果操作在定时器到期时还没有完成，那么就出现了问题。网络系统，事实上，基本上是一个由大量定时器控制的复杂状态机的集合。因此，网络代码处于一个很好的位置，可以作为其常规操作的一部分来检测传输超时。

因此，网络驱动程序不需要担心自己检测这样的问题。相反，他们只需要设置一个超时期，这个期限放在`net_device`结构的`watchdog_timeo`字段中。这个期限（以jiffies为单位）应该足够长，以考虑到正常的传输延迟（如由网络媒体上的拥塞引起的碰撞）。

如果当前系统时间超过设备的`trans_start`时间至少超过超时期，网络层最终会调用驱动程序的`tx_timeout`方法。该方法的任务是做任何需要的事情来清理问题，并确保已经在进行的任何传输的正确完成。特别重要的是，驱动程序不应该丢失任何已经被网络代码委托给它的套接字缓冲区。

`snull`有能力模拟发射器锁定，这是由两个加载时间参数控制的：
```c
static int lockup = 0;

module_param(lockup, int, 0);

static int timeout = SNULL_TIMEOUT;

module_param(timeout, int, 0);
```
如果驱动程序加载了参数`lockup=n`，那么每传输n个数据包就模拟一次锁定，并将`watchdog_timeo`字段设置为给定的超时值。在模拟锁定时，`snull`还调用`netif_stop_queue`来防止其他传输尝试发生。

`snull`的传输超时处理程序如下：
```c
void snull_tx_timeout (struct net_device *dev)

{

    struct snull_priv *priv = netdev_priv(dev);

    PDEBUG("Transmit timeout at %ld, latency %ld\n", jiffies,

            jiffies - dev->trans_start);

        /* Simulate a transmission interrupt to get things moving */

    priv->status = SNULL_TX_INTR;

    snull_interrupt(0, dev, NULL);

    priv->stats.tx_errors++;

    netif_wake_queue(dev);

    return;

}
```
当发生传输超时时，驱动程序必须在接口统计中标记错误，并安排设备被重置为一个理智的状态，以便可以传输新的数据包。当`snull`中发生超时时，驱动程序调用`snull_interrupt`来填充“缺失”的中断，并使用`netif_wake_queue`重新启动传输队列。



### 17.5.3. 发散/汇聚 I/O

在网络上创建一个用于传输的数据包的过程涉及到组装多个部分。数据包数据通常必须从用户空间复制进来，还必须添加各级网络堆栈使用的头部。这个组装可能需要相当多的数据复制。然而，如果预定传输数据包的网络接口可以执行散射/聚集I/O，那么数据包不需要被组装成一个单一的块，可以避免大部分的复制。散射/聚集I/O还使得可以直接从用户空间缓冲区进行网络数据的“零复制”传输。

除非在设备结构的特性字段中设置了`NETIF_F_SG`位，否则内核不会将散射的数据包传递给你的`hard_start_xmit`方法。如果你设置了这个标志，你需要查看skb中的一个特殊的“共享信息”字段，看看数据包是由一个片段还是多个片段组成，如果需要的话，找到散射的片段。有一个特殊的宏可以访问这个信息，它叫做`skb_shinfo`。当传输可能被分段的数据包时，第一步通常是这样的：
```c
if (skb_shinfo(skb)->nr_frags == 0) {

    /* Just use skb->data and skb->len as usual */

}
```
`nr_frags`字段告诉我们用了多少片段来构建数据包。如果它是0，那么数据包存在于一个单一的片段中，可以像往常一样通过data字段访问。然而，如果它是非零的，你的驱动程序必须通过并安排传输每个单独的片段。skb结构的data字段方便地指向第一个片段（与完整的数据包相比，就像在未分段的情况下一样）。片段的长度必须通过从skb->len中减去skb->data_len来计算（它仍然包含完整数据包的长度）。剩下的片段可以在共享信息结构中名为frags的数组中找到；frags中的每个条目都是一个`skb_frag_struct`结构：
```c
struct skb_frag_struct {

    struct page *page:

    __u16 page_offset;

    __u16 size;

};
```
如你所见，我们又一次处理的是页面结构，而不是内核虚拟地址。你的驱动程序应该循环遍历片段，为每个DMA传输映射每个片段，不要忘记第一个片段，它是由skb直接指向的。你的硬件，当然，必须组装片段并将它们作为一个单一的数据包传输。注意，如果你设置了`NETIF_F_HIGHDMA`特性标志，一些或所有的片段可能位于高内存中。


## 17.6. 报文接收
从网络接收数据比传输数据更棘手，因为必须在原子上下文中分配一个`sk_buff`并将其交给上层。网络驱动程序可能实现两种接收数据包的模式：中断驱动和轮询。大多数驱动程序实现中断驱动技术，这是我们首先介绍的。一些高带宽适配器的驱动程序也可能实现轮询技术；我们在“接收中断缓解”一节中看到这种方法。

`snull`的实现将“硬件”细节与设备无关的家务事务分开。因此，当硬件接收到数据包，并且它已经在计算机的内存中时，从`snull`的“中断”处理程序调用`snull_rx`函数。`snull_rx`接收到一个指向数据的指针和数据包的长度；它的唯一责任是将数据包和一些额外的信息发送到网络代码的上层。这段代码与获取数据指针和长度的方式无关。
以下是`snull_rx`函数的实现：

```c
void snull_rx(struct net_device *dev, struct snull_packet *pkt)
{
    struct sk_buff *skb;
    struct snull_priv *priv = netdev_priv(dev);
    /*
    *
    The packet has been retrieved from the transmission

    *
    medium. Build an skb around it, so upper layers can handle it
    */
    skb = dev_alloc_skb(pkt->datalen + 2);
    if (!skb) {

        if (printk_ratelimit())
            printk(KERN_NOTICE "snull rx: low on mem - packet dropped\n"); priv->stats.rx_dropped++; goto out;
    }
    memcpy(skb_put(skb, pkt->datalen), pkt->data, pkt->datalen);

    /* Write metadata, and then pass to the receive level */
    skb->dev = dev;
    skb->protocol = eth_type_trans(skb, dev);
    skb->ip_summed = CHECKSUM_UNNECESSARY; /* don't check it */
    priv->stats.rx_packets++;
    priv->stats.rx_bytes += pkt->datalen;
    netif_rx(skb);
out:
    return;
}
```


这个函数足够通用，可以作为任何网络驱动程序的模板，但在你有信心重用这段代码片段之前，需要一些解释。

首先，需要分配一个缓冲区来存储数据包。注意，缓冲区分配函数（`dev_alloc_skb`）需要知道数据长度。这个信息被函数用来为缓冲区分配空间。`dev_alloc_skb`以原子优先级调用`kmalloc`，所以它可以在中断时间安全地使用。内核提供了其他的套接字缓冲区分配接口，但在这里介绍它们并不值得；套接字缓冲区在“套接字缓冲区”一节中详细解释。

当然，必须检查`dev_alloc_skb`的返回值，`snull`就是这样做的。然而，在抱怨失败之前，我们调用`printk_ratelimit`。每秒生成数百或数千条控制台消息是让系统完全陷入困境并隐藏问题真正来源的好方法；`printk_ratelimit`通过在输出过多到控制台时返回0，需要稍微放慢一点，帮助防止这个问题。

一旦有了一个有效的`skb`指针，通过调用`memcpy`将数据包数据复制到缓冲区中；`skb_put`函数更新缓冲区中的数据结束指针，并返回一个指向新创建空间的指针。

如果你正在为一个可以进行全总线主控I/O的接口编写高性能驱动程序，这里有一个可能值得考虑的优化。一些驱动程序在接收数据包之前就为它们分配套接字缓冲区，然后指示接口将数据包数据直接放入套接字缓冲区的空间。网络层通过在DMA能够的空间（如果你的设备设置了`NETIF_F_HIGHDMA`特性标志，可能在高内存中）分配所有套接字缓冲区，配合这种策略。这样做可以避免填充套接字缓冲区时需要的单独复制操作，但需要小心缓冲区大小，因为你不会提前知道传入数据包的大小。在这种情况下，实现一个`change_mtu`方法也很重要，因为它允许驱动程序响应最大数据包大小的变化。

在网络层能理解数据包之前，需要明确一些信息。为此，必须在将缓冲区传递给上层之前分配`dev`和`protocol`字段。以太网支持代码导出了一个辅助函数（`eth_type_trans`），它找到一个适当的值放入`protocol`。然后我们需要指定如何对数据包进行校验和，或者已经对数据包进行了校验和（`snull`不需要进行任何校验和）。`skb->ip_summed`的可能策略有：

-   `CHECKSUM_HW`：设备已经在硬件中执行了校验和。一个硬件校验和的例子是SPARC HME接口。
-   `CHECKSUM_NONE`：校验和尚未被验证，任务必须由系统软件完成。这是新分配的缓冲区中的默认值。
-   `CHECKSUM_UNNECESSARY`：不做任何校验和。这是`snull`和环回接口中的策略。

你可能会想知道，为什么在我们已经在`net_device`结构的特性字段中设置了一个标志后，还需要在这里指定校验和状态。答案是，特性标志告诉内核我们的设备如何处理传出数据包。它不用于传入数据包，传入数据包必须单独标记。

最后，驱动程序更新其统计计数器，记录已经接收到一个数据包。统计结构由几个字段组成；最重要的是`rx_packets`、`rx_bytes`、`tx_packets`和`tx_bytes`，它们包含接收和发送的数据包数量以及传输的总字节数。所有字段在“统计信息”一节中都有详细的描述。

接收数据包的最后一步由`netif_rx`执行，它将套接字缓冲区交给上层。`netif_rx`实际上返回一个整数值；`NET_RX_SUCCESS`（0）表示数据包已成功接收；任何其他值都表示有问题。有三个返回值（`NET_RX_CN_LOW`、`NET_RX_CN_MOD`和`NET_RX_CN_HIGH`）表示网络子系统中拥塞的增加级别；`NET_RX_DROP`表示数据包被丢弃。驱动程序可以使用这些值在拥塞变高时停止向内核输入数据包，但实际上，大多数驱动程序忽略了`netif_rx`的返回值。如果你正在为一个高带宽设备编写驱动程序，并希望在拥塞时做出正确的反应，最好的方法是实现NAPI，我们在快速讨论中断处理程序后会讲到这个。

## 17.7. 中断处理

大多数硬件接口是通过中断处理程序来控制的。硬件中断处理器用来表示两种可能的事件之一：新的数据包已经到达或者传出数据包的传输已经完成。网络接口也可以生成中断来表示错误、链路状态变化等。

通常的中断例程可以通过检查在物理设备上找到的状态寄存器来区分新的数据包到达中断和完成传输通知。`snull`接口的工作方式类似，但它的状态字是在软件中实现的，并且存在于`dev->priv`中。


```c
static void snull_regular_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
    int statusword;
    struct snull_priv *priv;
    struct snull_packet *pkt = NULL;
    /*

    *
    As usual, check the "device" pointer to be sure it is

    *
    really interrupting.

    *
    Then assign "struct device *dev"

    */
    struct net_device *dev = (struct net_device *)dev_id;
    /* ... and check with hw if it's really ours */

    /* paranoid */
    if (!dev)
        return;

    /* Lock the device */
    priv = netdev_priv(dev);
    spin_lock(&priv->lock);

    /* retrieve statusword: real netdevices use I/O instructions */
    statusword = priv->status;
    priv->status = 0;
    if (statusword & SNULL_RX_INTR) {

        /* send it to snull_rx for handling */
        pkt = priv->rx_queue;
        if (pkt) {

            priv->rx_queue = pkt->next;
            snull_rx(dev, pkt);

        }
    }
    if (statusword & SNULL_TX_INTR) {

        /* a transmission is over: free the skb */
        priv->stats.tx_packets++;
        priv->stats.tx_bytes += priv->tx_packetlen;
        dev_kfree_skb(priv->skb);

    }

    /* Unlock the device and we are done */
    spin_unlock(&priv->lock);
    if (pkt) snull_release_buffer(pkt); /* Do this outside the lock! */
    return;

}
```

处理程序的第一项任务是检索指向正确的`struct net_device`的指针。这个指针通常来自作为参数接收的`dev_id`指针。

这个处理程序的有趣部分处理的是“传输完成”的情况。在这种情况下，更新统计信息，并调用`dev_kfree_skb`将（不再需要的）套接字缓冲区返回给系统。实际上，有三种可能被调用的这个函数的变体：
```c
dev_kfree_skb(struct sk_buff *skb);
```
当你知道你的代码不会在中断上下文中运行时，应该调用这个版本。由于`snull`没有实际的硬件中断，所以我们使用这个版本。
```c
dev_kfree_skb_irq(struct sk_buff *skb);
```
如果你知道你将在中断处理程序中释放缓冲区，使用这个版本，它针对这种情况进行了优化。
```c
dev_kfree_skb_any(struct sk_buff *skb);
```
如果相关的代码可能在中断或非中断上下文中运行，使用这个版本。

最后，如果你的驱动程序暂时停止了传输队列，这通常是用`netif_wake_queue`重新启动它的地方。

与传输相比，数据包接收不需要任何特殊的中断处理。调用`snull_rx`（我们已经看过）就足够了。

## 17.8. 接收中断缓解
当网络驱动程序按照我们上述的方式编写时，处理器会因为你的接口接收到的每个数据包而中断。在许多情况下，这是期望的操作模式，并不是问题。然而，高带宽接口可以每秒接收数千个数据包。在这种中断负载下，系统的整体性能可能会受到影响。

为了提高Linux在高端系统上的性能，网络子系统的开发者创建了一个基于轮询的替代接口（称为NAPI）。在驱动程序开发者中，“轮询”可能是一个贬义词，他们通常认为轮询技术既不优雅又低效。然而，只有当接口在没有工作要做的时候被轮询时，轮询才是低效的。当系统有一个处理大量流量的高速接口时，总是有更多的数据包要处理。在这种情况下，没有必要中断处理器；只需要每隔一段时间从接口收集新的数据包就足够了。

停止接收中断可以大大减轻处理器的负载。NAPI兼容的驱动程序也可以被告知，如果这些数据包由于拥塞而在网络代码中被丢弃，就不要将数据包输入到内核中，这也可以在最需要帮助的时候提高性能。由于各种原因，NAPI驱动程序也不太可能重新排序数据包。

然而，并非所有设备都能在NAPI模式下运行。一个能够使用NAPI的接口必须能够存储几个数据包（要么在卡本身上，要么在内存DMA环中）。接口应该能够禁用接收到的数据包的中断，同时继续中断成功的传输和其他事件。

还有其他一些微妙的问题可能使编写NAPI兼容的驱动程序更困难；在内核源代码树中的`Documentation/networking/NAPI_HOWTO.txt`中可以看到详细信息。

相对较少的驱动程序实现了NAPI接口。然而，如果你正在为一个可能会产生大量中断的接口编写驱动程序，花时间实现NAPI可能会证明是值得的。

当`snull`驱动程序加载时，如果`use_napi`参数设置为非零值，它将在NAPI模式下运行。在初始化时，我们需要设置一些额外的`struct net_device`字段：
```c
if (use_napi) {

    dev->poll        = snull_poll;

    dev->weight      = 2;

}
```
`poll`字段必须设置为你的驱动程序的轮询函数；我们稍后会看到`snull_poll`。`weight`字段描述了接口的相对重要性：当资源紧张时，应该从接口接收多少流量。对于如何设置`weight`参数没有严格的规则；按照惯例，10 MBps的以太网接口将`weight`设置为16，而更快的接口使用64。你不应该将`weight`设置为大于你的接口可以存储的数据包数量。在`snull`中，我们将`weight`设置为2，以此来演示延迟的数据包接收。

创建NAPI兼容驱动程序的下一步是改变中断处理程序。当你的接口（应该开始时接收中断已经启用）信号一个数据包已经到达时，中断处理程序不应该处理那个数据包。相反，它应该禁用进一步的接收中断，并告诉内核现在是开始轮询接口的时候了。在`snull`的“中断”处理程序中，响应数据包接收中断的代码已经被改变为以下内容：
```c
if (statusword & SNULL_RX_INTR) {

    snull_rx_ints(dev, 0);  /* Disable further interrupts */

    netif_rx_schedule(dev);

}
```
当接口告诉我们一个数据包可用时，中断处理程序将其留在接口中；此时需要做的就是调用`netif_rx_schedule`，这将导致我们的`poll`方法在未来某个时刻被调用。

poll 方法有下面原型:

```c

int (*poll)(struct net_device *dev, int *budget); 

```

snull 的 poll 方法实现看来如此:

```c

static int snull_poll(struct net_device *dev, int *budget)
{
    int npackets = 0, quota = min(dev->quota, *budget);
    struct sk_buff *skb;
    struct snull_priv *priv = netdev_priv(dev);
    struct snull_packet *pkt;

    while (npackets < quota && priv->rx_queue) {
        pkt = snull_dequeue_buf(dev);
        skb = dev_alloc_skb(pkt->datalen + 2);
        if (! skb) {

            if (printk_ratelimit())
                printk(KERN_NOTICE "snull: packet dropped\n"); priv->stats.rx_dropped++; snull_release_buffer(pkt); continue;
        }
        memcpy(skb_put(skb, pkt->datalen), pkt->data, pkt->datalen);
        skb->dev = dev;
        skb->protocol = eth_type_trans(skb, dev);
        skb->ip_summed = CHECKSUM_UNNECESSARY; /* don't check it */
        netif_receive_skb(skb);

        /* Maintain stats */
        npackets++;
        priv->stats.rx_packets++;
        priv->stats.rx_bytes += pkt->datalen;
        snull_release_buffer(pkt);

    }
    /* If we processed all packets, we're done; tell the kernel and reenable ints */
    *budget -= npackets;
    dev->quota -= npackets;
    if (! priv->rx_queue) {

        netif_rx_complete(dev);
        snull_rx_ints(dev, 1);
        return 0;

    }
    /* We couldn't process everything. */
    return 1;

}
```

函数的核心部分涉及到创建一个skb来保存数据包；这段代码与我们之前在`snull_rx`中看到的是一样的。然而，有一些事情是不同的：

-   `budget`参数提供了我们被允许传入内核的最大数据包数量。在设备结构中，`quota`字段给出了另一个最大值；`poll`方法必须尊重这两个限制中的较低者。它还应该将`dev->quota`和`*budget`减去实际接收到的数据包数量。`budget`值是当前CPU可以从所有接口接收的最大数据包数量，而`quota`是一个每个接口的值，通常在初始化时开始作为分配给接口的权重。
-   数据包应该使用`netif_receive_skb`，而不是`netif_rx`，提供给内核。
-   如果`poll`方法能够在给定的限制内处理所有可用的数据包，它应该重新启用接收中断，调用`netif_rx_complete`来关闭轮询，并返回0。返回值1表示还有数据包需要处理。

网络子系统保证任何给定设备的`poll`方法不会在多于一个处理器上并发调用。然而，对`poll`的调用仍然可以与对你的其他设备方法的调用并发进行。


## 17.9. 连接状态的改变
网络连接，顾名思义，处理的是本地系统之外的世界。因此，它们经常受到外部事件的影响，它们可能是瞬态的。网络子系统需要知道网络链接何时上线或下线，它提供了一些驱动程序可以用来传达这些信息的函数。

大多数涉及实际物理连接的网络技术都提供一个载波状态；载波的存在意味着硬件存在并准备好工作。例如，以太网适配器在电线上感知载波信号；当用户绊倒在电缆上时，那个载波消失，链接断开。默认情况下，网络设备被认为有一个载波信号存在。然而，驱动程序可以使用以下函数显式改变这个状态：
```c
void netif_carrier_off(struct net_device *dev);

void netif_carrier_on(struct net_device *dev);
```
如果你的驱动程序在其设备之一上检测到缺少载波，它应该调用`netif_carrier_off`来通知内核这个变化。当载波返回时，应该调用`netif_carrier_on`。一些驱动程序在进行重大配置更改（如媒体类型）时也会调用`netif_carrier_off`；一旦适配器完成了重置自身，新的载波被检测到，流量可以恢复。

还存在一个整数函数：
```c
int netif_carrier_ok(struct net_device *dev);
```
这个函数可以用来测试当前的载波状态（如在设备结构中反映的那样）。


## 17.10. Socket 缓存

我们现在已经涵盖了大部分与网络接口相关的问题。仍然缺少的是对`sk_buff`结构的更详细讨论。这个结构是Linux内核网络子系统的核心，我们现在将介绍结构的主要字段和用于操作它的函数。

虽然没有严格的需要理解`sk_buff`的内部结构，但是能够查看其内容在你追踪问题和试图优化你的代码时可能会有所帮助。例如，如果你查看`loopback.c`，你会发现一个基于`sk_buff`内部知识的优化。这里适用通常的警告：如果你编写的代码利用了对`sk_buff`结构的知识，你应该准备好看到它在未来的内核版本中出现问题。然而，有时候性能优势可以证明额外的维护成本是值得的。

我们不打算在这里描述整个结构，只描述可能在驱动程序中使用的字段。如果你想看更多，你可以查看`<linux/skbuff.h>`，在那里定义了结构并原型化了函数。关于字段和函数如何使用的额外细节可以通过在内核源代码中使用grep轻松检索到。


### 17.10.1. 重要成员变量
这里介绍的字段是驱动程序可能需要访问的字段。它们没有特定的顺序。
```c
struct net_device *dev;
```
接收或发送此缓冲区的设备。
```c
union { /* ... */ } h;

union { /* ... */ } nh;

union { /*... */} mac;
```
指向包含在数据包中的各级头部的指针。联合的每个字段都是指向不同类型数据结构的指针。h托管指向传输层头部的指针（例如，`struct tcphdr *th`）；nh包括网络层头部（如`struct iphdr *iph`）；mac收集指向链路层头部的指针（如`struct ethdr *ethernet`）。

如果你的驱动程序需要查看TCP数据包的源地址和目标地址，它可以在skb->h.th中找到它们。查看头文件可以看到可以通过这种方式访问的头类型的完整集合。

注意，网络驱动程序负责为传入的数据包设置mac指针。这个任务通常由eth_type_trans处理，但非以太网驱动程序必须直接设置skb->mac.raw，如“非以太网头部”一节中所示。
```c
unsigned char *head;

unsigned char *data;

unsigned char *tail;

unsigned char *end;
```
用于寻址数据包中的数据的指针。head指向分配空间的开始，data是有效字节的开始（通常比head稍大），tail是有效字节的结束，end指向tail可以到达的最大地址。另一种看法是，可用的缓冲区空间是skb->end - skb->head，当前使用的数据空间是skb->tail - skb->data。
```c
unsigned int len;

unsigned int data_len;
```
len是数据包中数据的全长，而data_len是存储在单独片段中的数据包部分的长度。除非使用散列/聚集I/O，否则data_len字段为0。
```c
unsigned char ip_summed;
```
此数据包的校验和策略。驱动程序在接收数据包时设置该字段，如“数据包接收”一节中所述。
```c
unsigned char pkt_type;
```
数据包在其传递中使用的分类。驱动程序负责将其设置为PACKET_HOST（这个数据包是为我），PACKET_OTHERHOST（不，这个数据包不是为我），PACKET_BROADCAST或PACKET_MULTICAST。以太网驱动程序不显式修改pkt_type，因为eth_type_trans为它们做了。
```c
shinfo(struct sk_buff *skb);

unsigned int shinfo(skb)->nr_frags;

skb_frag_t shinfo(skb)->frags;
```
出于性能原因，一些skb信息存储在内存中紧接着skb的单独结构中。这个“共享信息”（因为它可以在网络代码中的skb副本之间共享）必须通过shinfo宏访问。这个结构中有几个字段，但大多数都超出了本书的范围。我们在“散列/聚集I/O”一节中看到了nr_frags和frags。

结构中的其余字段并不特别有趣。它们用于维护缓冲区列表，记账属于拥有缓冲区的套接字的内存等。



### 17.10.2. 作用于 socket 缓存的函数
使用`sk_buff`结构的网络设备通过官方接口函数对其进行操作。许多函数操作套接字缓冲区；这里是最有趣的一些：
```c
struct sk_buff *alloc_skb(unsigned int len, int priority);

struct sk_buff *dev_alloc_skb(unsigned int len);
```
分配一个缓冲区。`alloc_skb`函数分配一个缓冲区并初始化`skb->data`和`skb->tail`为`skb->head`。`dev_alloc_skb`函数是一个快捷方式，它以`GFP_ATOMIC`优先级调用`alloc_skb`并在`skb->head`和`skb->data`之间预留一些空间。这个数据空间用于网络层内的优化，驱动程序不应触碰它。
```c
void kfree_skb(struct sk_buff *skb);

void dev_kfree_skb(struct sk_buff *skb);

void dev_kfree_skb_irq(struct sk_buff *skb);

void dev_kfree_skb_any(struct sk_buff *skb);
```
释放一个缓冲区。`kfree_skb`调用由内核内部使用。驱动程序应使用`dev_kfree_skb`的一种形式：非中断上下文使用`dev_kfree_skb`，中断上下文使用`dev_kfree_skb_irq`，或者可以在任一上下文中运行的代码使用`dev_kfree_skb_any`。
```c
unsigned char *skb_put(struct sk_buff *skb, int len);

unsigned char *__skb_put(struct sk_buff *skb, int len);
```
更新`sk_buff`结构的`tail`和`len`字段；它们用于在缓冲区的末尾添加数据。每个函数的返回值是`skb->tail`的前一个值（换句话说，它指向刚刚创建的数据空间）。驱动程序可以使用返回值通过调用`memcpy(skb_put(...), data, len)`或等效的方式复制数据。两个函数的区别在于，`skb_put`检查数据是否适合在缓冲区中，而`__skb_put`省略了检查。
```c
unsigned char *skb_push(struct sk_buff *skb, int len);

unsigned char *__skb_push(struct sk_buff *skb, int len);
```
减少`skb->data`并增加`skb->len`的函数。它们与`skb_put`类似，只是数据是添加到数据包的开始而不是结束。返回值指向刚刚创建的数据空间。这些函数用于在传输数据包之前添加硬件头部。再次，`__skb_push`的区别在于它不检查是否有足够的可用空间。
```c
int skb_tailroom(struct sk_buff *skb);
```
返回在缓冲区中放入数据的可用空间量。如果驱动程序在缓冲区中放入的数据超过了它可以容纳的量，系统会发生恐慌。虽然你可能反对使用`printk`就足以标记错误，但内存损坏对系统的危害如此之大，以至于开发者决定采取决定性的行动。在实践中，如果缓冲区已经正确分配，你不应该需要检查可用空间。由于驱动程序通常在分配缓冲区之前获取数据包大小，只有严重损坏的驱动程序才会在缓冲区中放入过多的数据，而且可能会被视为应得的惩罚。
```c
int skb_headroom(struct sk_buff *skb);
```
返回在数据前面可用的空间量，也就是可以“推送”到缓冲区的字节数。
```c
void skb_reserve(struct sk_buff *skb, int len);
```
增加`data`和`tail`。该函数可用于在填充缓冲区之前预留头部空间。大多数以太网接口在数据包前面预留两个字节；因此，IP头部在14字节的以太网头部之后对齐在16字节的边界上。`snull`也这样做，尽管在“数据包接收”中没有显示这个指令，以避免在那个时候引入额外的概念。
```c
unsigned char *skb_pull(struct sk_buff *skb, int len);
```
从数据包的头部移除数据。驱动程序不需要使用这个函数，但为了完整性在这里包含了它。它减少`skb->len`并增加`skb->data`；这就是如何从传入数据包的开始剥离硬件头部（以太网或等效的）。
```c
int skb_is_nonlinear(struct sk_buff *skb);
```
如果这个`skb`被分割成多个片段用于散射/收集I/O，返回一个真值。
```c
int skb_headlen(struct sk_buff *skb);
```
返回`skb`的第一个段的长度（由`skb->data`指向的部分）。
```c
void *kmap_skb_frag(skb_frag_t *frag);

void kunmap_skb_frag(void *vaddr);
```
如果你必须直接从内核中访问非线性`skb`的片段，这些函数为你映射和取消映射它们。使用了原子`kmap`，所以你不能同时映射多个片段。

内核定义了几个其他的操作套接字缓冲区的函数，但它们是用于在网络代码的更高层次中使用的，驱动程序不需要它们。



## 17.11. MAC 地址解析
以太网通信的一个有趣问题是如何将MAC地址（接口的唯一硬件ID）与IP号码关联起来。大多数协议都有类似的问题，但我们在这里主要关注以太网类的情况。我们试图提供问题的完整描述，所以我们展示了三种情况：ARP，没有ARP的以太网头（如plip），和非以太网头。

1.  ARP（地址解析协议）：ARP是一种协议，用于在网络上查找给定IP地址的MAC地址。当一个设备需要将数据包发送到特定的IP地址时，它首先查看其ARP缓存，看看它是否已经知道该IP地址的MAC地址。如果没有，它将广播一个ARP请求，询问哪个设备拥有该IP地址。拥有该IP地址的设备将回复其MAC地址，发送设备将更新其ARP缓存，并将数据包发送到正确的MAC地址。
```c
struct ethhdr *eth;

struct iphdr *ip;

skb->dev = dev;

skb->protocol = htons(ETH_P_IP);

ip = ip_hdr(skb);

ip->saddr = inet_select_addr(dev, dst, RT_SCOPE_LINK);

eth = (struct ethhdr *)skb_push(skb, ETH_HLEN);

memcpy(eth->h_source, dev->dev_addr, ETH_ALEN);
```
2.  无ARP的以太网头（如plip）：在某些情况下，设备可能不使用ARP来查找MAC地址。例如，plip（并行线IP）是一种在两台计算机之间使用并行线进行通信的协议。在这种情况下，设备可能会直接设置MAC地址。
```c
struct ethhdr *eth;

skb->dev = dev;

skb->protocol = htons(ETH_P_IP);

eth = (struct ethhdr *)skb_push(skb, ETH_HLEN);

memcpy(eth->h_source, dev->dev_addr, ETH_ALEN);

memcpy(eth->h_dest, dev->broadcast, ETH_ALEN);
```
3.  非以太网头：在某些情况下，设备可能不使用以太网头，而是使用其他类型的头，如帧中继或ATM。在这种情况下，设备将需要使用适当的协议来查找和设置目标地址。
```c
struct atmhdr *atm;

skb->dev = dev;

skb->protocol = htons(ETH_P_IP);

atm = (struct atmhdr *)skb_push(skb, sizeof(struct atmhdr));

atm->vpi = dev->vpi;

atm->vci = dev->vci;
```
以上代码块都是在C语言中编写的，它们展示了如何在不同的网络协议中设置网络头。



### 17.11.1. 以太网使用 ARP
通常处理地址解析的方式是使用地址解析协议（ARP）。幸运的是，ARP由内核管理，以太网接口不需要做任何特殊的操作来支持ARP。只要在打开时正确分配了`dev->addr`和`dev->addr_len`，驱动程序就不需要担心将IP号解析为MAC地址；`ether_setup`将正确的设备方法分配给`dev->hard_header`和`dev->rebuild_header`。

虽然内核通常处理地址解析的细节（和结果的缓存），但它调用接口驱动程序来帮助构建数据包。毕竟，驱动程序知道物理层头部的细节，而网络代码的作者试图将内核的其余部分与这种知识隔离。为此，内核调用驱动程序的`hard_header`方法，使用ARP查询的结果来布局数据包。通常，以太网驱动程序的编写者不需要知道这个过程——通用的以太网代码会处理所有事情。



### 17.11.2. 不考虑 ARP

简单的点对点网络接口，如`plip`，可能会从使用以太网头部中受益，同时避免发送ARP包来回的开销。`snull`中的示例代码也属于这类网络设备。`snull`不能使用ARP，因为驱动程序在传输的数据包中改变IP地址，而ARP包也交换IP地址。尽管我们可以轻松地实现一个简单的ARP回复生成器，但直接处理物理层头部更具有说明性。

如果你的设备想要使用通常的硬件头部而不运行ARP，你需要覆盖默认的`dev->hard_header`方法。这就是`snull`如何实现它的，作为一个非常短的函数：
```c
int snull_header(struct sk_buff *skb, struct net_device *dev,

                unsigned short type, void *daddr, void *saddr,

                unsigned int len)

{

    struct ethhdr *eth = (struct ethhdr *)skb_push(skb,ETH_HLEN);

    eth->h_proto = htons(type);

    memcpy(eth->h_source, saddr ? saddr : dev->dev_addr, dev->addr_len);

    memcpy(eth->h_dest,   daddr ? daddr : dev->dev_addr, dev->addr_len);

    eth->h_dest[ETH_ALEN-1]   ^= 0x01;   /* dest is us xor 1 */

    return (dev->hard_header_len);

}
```
该函数简单地取得内核提供的信息，并将其格式化为标准的以太网头部。它还在目标以太网地址中切换一个位，原因将在后面描述。

当接口接收到一个数据包时，硬件头部被`eth_type_trans`以几种方式使用。我们已经在`snull_rx`中看到了这个调用：
```c
skb->protocol = eth_type_trans(skb, dev);
```
该函数从以太网头部提取协议标识符（在这种情况下为`ETH_P_IP`）；它还分配`skb->mac.raw`，从数据包数据中移除硬件头部（使用`skb_pull`），并设置`skb->pkt_type`。这最后一项在skb分配时默认为`PACKET_HOST`（表示数据包是定向到这个主机的），`eth_type_trans`改变它以反映以太网目标地址：如果该地址不匹配接收到它的接口的地址，`pkt_type`字段被设置为`PACKET_OTHERHOST`。随后，除非接口处于混杂模式或在内核中启用了数据包转发，`netif_rx`会丢弃任何类型为`PACKET_OTHERHOST`的数据包。因此，`snull_header`小心地使目标硬件地址匹配“接收”接口的地址。

如果你的接口是一个点对点链接，你不会想要接收意外的多播数据包。为了避免这个问题，记住，其第一个八位字节的最低有效位（LSB）为0的目标地址是定向到单个主机的（即，它是`PACKET_HOST`或`PACKET_OTHERHOST`）。`plip`驱动程序使用`0xfc`作为其硬件地址的第一个八位字节，而`snull`使用`0x00`。两个地址都会产生一个工作的以太网类点对点链接。


### 17.11.3. 非以太网头部

我们刚刚看到，硬件头部除了目标地址外，还包含一些信息，最重要的是通信协议。我们现在描述如何使用硬件头部来封装相关信息。如果你需要知道细节，你可以从内核源代码或特定传输介质的技术文档中提取它们。大多数驱动程序编写者可以忽略这个讨论，只使用以太网实现。

值得注意的是，并非所有信息都必须由每个协议提供。像`plip`或`snull`这样的点对点链接可以避免传输整个以太网头部而不失一般性。`hard_header`设备方法，如前面所示由`snull_header`实现，从内核接收交付信息——协议级和硬件地址。它还接收`type`参数中的16位协议号；例如，IP由`ETH_P_IP`标识。驱动程序应正确地将数据包数据和协议号交付给接收主机。点对点链接可以从其硬件头部省略地址，只传输协议号，因为交付是独立于源和目标地址的。一个只有IP的链接甚至可以避免传输任何硬件头部。

当数据包在链接的另一端被接收时，驱动程序中的接收函数应正确地设置字段`skb->protocol`，`skb->pkt_type`，和`skb->mac.raw`。`skb->mac.raw`是一个字符指针，由网络代码的更高层（例如，`net/ipv4/arp.c`）实现的地址解析机制使用。它必须指向一个与`dev->type`匹配的机器地址。设备类型的可能值在`<linux/if_arp.h>`中定义；以太网接口使用`ARPHRD_ETHER`。例如，这是`eth_type_trans`如何处理接收到的数据包的以太网头部：
```c
skb->mac.raw = skb->data;

skb_pull(skb, dev->hard_header_len);
```
在最简单的情况下（一个没有头部的点对点链接），`skb->mac.raw`可以指向一个包含此接口的硬件地址的静态缓冲区，协议可以设置为`ETH_P_IP`，并且`packet_type`可以保留其默认值`PACKET_HOST`。

因为每种硬件类型都是唯一的，所以很难给出比已经讨论的更具体的建议。然而，内核中充满了例子。例如，看看AppleTalk驱动程序（`drivers/net/appletalk/cops.c`），红外驱动程序（如`drivers/net/irda/smc_ircc.c`），或PPP驱动程序（`drivers/net/ppp_generic.c`）。


## 17.12. 定制 ioctl 命令
我们已经看到`ioctl`系统调用是为套接字实现的；`SIOCSIFADDR`和`SIOCSIFMAP`是“套接字ioctl”的例子。现在让我们看看系统调用的第三个参数是如何被网络代码使用的。

当在套接字上调用`ioctl`系统调用时，命令号是在`<linux/sockios.h>`中定义的符号之一，`sock_ioctl`函数直接调用一个协议特定的函数（这里的“协议”指的是正在使用的主要网络协议，例如IP或AppleTalk）。

任何协议层未识别的`ioctl`命令都会传递给设备层。这些设备相关的`ioctl`命令接受一个来自用户空间的第三个参数，一个`struct ifreq *`。这个结构在`<linux/if.h>`中定义。`SIOCSIFADDR`和`SIOCSIFMAP`命令实际上是在`ifreq`结构上工作。`SIOCSIFMAP`的额外参数，虽然定义为`ifmap`，但只是`ifreq`的一个字段。

除了使用标准化的调用，每个接口都可以定义自己的`ioctl`命令。例如，`plip`接口允许通过`ioctl`修改其内部超时值。套接字的`ioctl`实现将16个命令识别为接口私有的：`SIOCDEVPRIVATE`到`SIOCDEVPRIVATE+15`。当识别到这些命令中的一个时，会在相关的接口驱动程序中调用`dev->do_ioctl`。该函数接收与通用`ioctl`函数使用的相同的`struct ifreq *`指针：
```c
int (*do_ioctl)(struct net_device *dev, struct ifreq *ifr, int cmd);
```
`ifr`指针指向一个内核空间地址，该地址保存了用户传递的结构的副本。`do_ioctl`返回后，该结构被复制回用户空间；因此，驱动程序可以使用私有命令来接收和返回数据。设备特定的命令可以选择使用`struct ifreq`中的字段，但它们已经传达了一个标准化的含义，驱动程序不太可能将结构适应于其需要。字段`ifr_data`是一个`caddr_t`项（一个指针），用于满足设备特定的需求。驱动程序和用于调用其`ioctl`命令的程序应该就`ifr_data`的使用达成一致。例如，`ppp-stats`使用设备特定的命令从`ppp`接口驱动程序中检索信息。

在这里展示`do_ioctl`的实现并不值得，但是有了本章的信息和内核的例子，你应该能够在需要时编写一个。然而，请注意，`plip`的实现错误地使用了`ifr_data`，不应该作为`ioctl`实现的例子。



## 17.13. 统计信息Statistical Information

驱动程序需要的最后一个方法是`get_stats`。这个方法返回设备的统计信息的指针。它的实现相当简单；即使有多个接口由同一个驱动程序管理，下面的实现也能正常工作，因为统计信息存储在设备数据结构中。
```c
struct net_device_stats *snull_stats(struct net_device *dev)

{

    struct snull_priv *priv = netdev_priv(dev);

    return &priv->stats;

}
```
需要返回有意义的统计信息的真正工作分布在驱动程序的各个地方，其中各个字段被更新。以下列表显示了`struct net_device_stats`中最有趣的字段：
```c
unsigned long rx_packets;

unsigned long tx_packets;
```
接口成功传输的入站和出站数据包的总数。
```c
unsigned long rx_bytes;

unsigned long tx_bytes;
```
接口接收和发送的字节数。
```c
unsigned long rx_errors;

unsigned long tx_errors;
```
错误接收和传输的数量。数据包传输可能出现各种问题，`net_device_stats`结构包含了6个特定接收错误和5个传输错误的计数器。查看`<linux/netdevice.h>`以获取完整列表。如果可能，你的驱动程序应该保持详细的错误统计信息，因为它们对于试图追踪问题的系统管理员最有帮助。
```c
unsigned long rx_dropped;

unsigned long tx_dropped;
```
在接收和传输过程中丢弃的数据包数量。当没有可用的内存用于数据包数据时，数据包会被丢弃。`tx_dropped`很少使用。
```c
unsigned long collisions;
```
由于媒体拥塞导致的碰撞次数。
```c
unsigned long multicast;
```
接收到的多播数据包的数量。

值得重复的是，`get_stats`方法可以在任何时候被调用——即使接口处于关闭状态——所以驱动程序必须保留统计信息，只要`net_device`结构存在。


## 17.14. 多播Multicast
多播数据包是一种网络数据包，它的目标是多个主机，但并非所有主机。这个功能是通过为主机组分配特殊的硬件地址来实现的。定向到其中一个特殊地址的数据包应该被该组中的所有主机接收。在以太网的情况下，多播地址在目标地址的第一个地址八位中设置了最低有效位，而每个设备板在其自己的硬件地址中都清除了该位。

处理主机组和硬件地址的棘手部分由应用程序和内核执行，接口驱动程序不需要处理这些问题。

多播数据包的传输是一个简单的问题，因为它们看起来就像其他任何数据包。接口将它们通过通信媒体传输，而不查看目标地址。内核必须分配一个正确的硬件目标地址；如果定义了`hard_header`设备方法，它不需要查看它安排的数据。

内核处理跟踪哪些多播地址在任何给定时间都是有趣的工作。这个列表可能会频繁改变，因为它是正在运行的应用程序和用户兴趣的函数。驱动程序的工作是接受有趣的多播地址列表，并将发送到这些地址的任何数据包交给内核。驱动程序如何实现多播列表在某种程度上取决于底层硬件的工作方式。通常，硬件属于以下三类之一，就多播而言：

-   不能处理多播的接口。这些接口要么接收定向到其硬件地址的数据包（加上广播数据包），要么接收每个数据包。它们只能通过接收每个数据包来接收多播数据包，从而可能会用大量的“无趣”数据包压倒操作系统。你通常不会把这些接口算作多播能力，驱动程序不会在`dev->flags`中设置`IFF_MULTICAST`。点对点接口是一个特殊情况，因为它们总是接收每个数据包，而不进行任何硬件过滤。
-   能够从其他数据包（主机到主机或广播）中区分出多播数据包的接口。这些接口可以被指示接收每个多播数据包，并让软件确定该地址是否对这个主机有趣。在这种情况下引入的开销是可以接受的，因为在典型的网络上多播数据包的数量是低的。
-   能够进行多播地址的硬件检测的接口。这些接口可以传递一个多播地址列表，对于这些地址的数据包应该被接收，并忽略其他多播数据包。这对于内核来说是最优的情况，因为它不会浪费处理器时间丢弃接口接收的“无趣”数据包。

内核试图通过支持第三类设备，这是最通用的，来充分利用高级接口的能力。因此，当有效多播地址列表发生变化时，内核会通知驱动程序，并将新列表传递给驱动程序，以便它可以根据新信息更新硬件过滤器。



### 17.14.1. 多播的内核支持

支持多播数据包由几个部分组成：设备方法、数据结构和设备标志：
```c
void (*dev->set_multicast_list)(struct net_device *dev);
```
设备方法在与设备关联的机器地址列表发生变化时被调用。当`dev->flags`被修改时，它也会被调用，因为一些标志（例如，`IFF_PROMISC`）可能也需要你重新编程硬件过滤器。该方法接收一个指向`struct net_device`的指针作为参数，并返回`void`。不感兴趣实现此方法的驱动程序可以将该字段设置为`NULL`。
```c
struct dev_mc_list *dev->mc_list;
```
与设备关联的所有多播地址的链接列表。该结构的实际定义将在本节的末尾介绍。
```c
int dev->mc_count;
```
链接列表中的项目数量。这个信息有些冗余，但是检查`mc_count`是否为0是检查列表的有用快捷方式。

`IFF_MULTICAST`

除非驱动程序在`dev->flags`中设置了此标志，否则接口不会被要求处理多播数据包。尽管如此，当`dev->flags`发生变化时，内核会调用驱动程序的`set_multicast_list`方法，因为在接口不活动时，多播列表可能已经改变。

`IFF_ALLMULTI`

网络软件在`dev->flags`中设置的标志，告诉驱动程序从网络中检索所有多播数据包。当启用多播路由时，就会发生这种情况。如果设置了该标志，`dev->mc_list`不应用于过滤多播数据包。

`IFF_PROMISC`

当接口被置入混杂模式时，在`dev->flags`中设置的标志。每个数据包都应由接口接收，与`dev->mc_list`无关。

驱动程序开发者需要的最后一点信息是`struct dev_mc_list`的定义，它位于`<linux/netdevice.h>`中：
```c
struct dev_mc_list {

    struct dev_mc_list   *next;          /* Next address in list */

    __u8                 dmi_addr[MAX_ADDR_LEN]; /* Hardware address */

    unsigned char        dmi_addrlen;    /* Address length */

    int                  dmi_users;      /* Number of users */

    int                  dmi_gusers;     /* Number of groups */

};
```
因为多播和硬件地址与实际的数据包传输是独立的，所以这个结构在网络实现中是可移植的，每个地址都由一个八位字节串和一个长度标识，就像`dev->dev_addr`一样。


### 17.14.2. 典型实现

以下是`set_multicast_list`设计的最佳描述方式，通过一些伪代码来展示。

以下函数是一个典型的在全功能（ff）驱动程序中的实现。驱动程序是全功能的，因为它控制的接口有一个复杂的硬件数据包过滤器，可以保存一个由此主机接收的多播地址的表。表的最大大小是`FF_TABLE_SIZE`。

所有以`ff_`为前缀的函数都是硬件特定操作的占位符：
```c
void ff_set_multicast_list(struct net_device *dev)

{

    struct dev_mc_list *mcptr;

    if (dev->flags & IFF_PROMISC) {

        ff_get_all_packets( );

        return;

    }

    /* If there are more addresses than we handle, get all multicast

    packets and sort them out in software. */

    if (dev->flags & IFF_ALLMULTI || dev->mc_count > FF_TABLE_SIZE) {

        ff_get_all_multicast_packets( );

        return;

    }

    /* No multicast?  Just get our own stuff */

    if (dev->mc_count == 0) {

        f_get_only_own_packets( );

        return;

    }

    /* Store all of the multicast addresses in the hardware filter */

    ff_clear_mc_list( );

    for (mc_ptr = dev->mc_list; mc_ptr; mc_ptr = mc_ptr->next)

        ff_store_mc_address(mc_ptr->dmi_addr);

    ff_get_packets_in_multicast_list( );

}
```
如果接口不能在硬件过滤器中存储入站数据包的多播表，那么这个实现可以被简化。在这种情况下，`FF_TABLE_SIZE`减少到0，最后四行代码不需要。

如前所述，即使是不能处理多播数据包的接口也需要实现`set_multicast_list`方法，以便在`dev->flags`发生变化时得到通知。这种方法可以被称为“非特性”（nf）实现。实现非常简单，如下面的代码所示：
```c
void nf_set_multicast_list(struct net_device *dev)

{

    if (dev->flags & IFF_PROMISC)

        nf_get_all_packets( );

    else

        nf_get_only_own_packets( );

}
```
实现`IFF_PROMISC`很重要，因为否则用户将无法运行`tcpdump`或任何其他网络分析器。另一方面，如果接口运行一个点对点链接，那么根本不需要实现`set_multicast_list`，因为用户无论如何都会接收到每个数据包。


## 17.15. 几个其他细节

这一部分将涵盖一些可能对网络驱动程序作者感兴趣的其他主题。在每种情况下，我们只是试图指引你正确的方向。要获得主题的完整画面，可能需要花一些时间深入研究内核源代码。

### 17.15.1. 独立于媒介的接口支持
媒体独立接口（或 MII）是一个 IEEE 802.3 标准，描述了以太网收发器如何与网络控制器接口；市场上许多产品都符合这个接口。如果你正在为一个符合 MII 的控制器编写驱动程序，内核提供了一个通用的 MII 支持层，可能会使你的生活更轻松。

要使用通用的 MII 层，你应该包含 `<linux/mii.h>`。你需要用关于收发器的物理 ID、是否实施全双工等信息填充一个 `mii_if_info` 结构。`mii_if_info` 结构还需要两个方法：
```c
int (*mdio_read) (struct net_device *dev, int phy_id, int location);

void (*mdio_write) (struct net_device *dev, int phy_id, int location, int val);
```
正如你可能预期的，这些方法应该实现与你特定的 MII 接口的通信。

通用的 MII 代码提供了一组函数，用于查询和改变收发器的操作模式；许多这些函数设计用于与 `ethtool` 实用程序（在下一节中描述）一起工作。在 `<linux/mii.h>` 和 `drivers/net/mii.c` 中查看详情。



### 17.15.2. ethtool 支持
Ethtool 是一个设计用来给系统管理员提供对网络接口操作的大量控制的实用程序。使用 ethtool，可以控制各种接口参数，包括速度、媒体类型、双工操作、DMA 环设置、硬件校验和、唤醒局域网操作等，但前提是驱动程序支持 ethtool。Ethtool 可以从 [http://sf.net/projects/gkernel/](vscode-file://vscode-app/d:/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html "http://sf.net/projects/gkernel/") 下载。

对于 ethtool 支持的相关声明可以在 `<linux/ethtool.h>` 中找到。核心是一个类型为 `ethtool_ops` 的结构，它包含了全24个不同的 ethtool 支持方法。这些方法大多数都相对直接；查看 `<linux/ethtool.h>` 获取详情。如果你的驱动程序正在使用 MII 层，你可以使用 `mii_ethtool_gset` 和 `mii_ethtool_sset` 来分别实现 `get_settings` 和 `set_settings` 方法。

为了让 ethtool 与你的设备一起工作，你必须在 `net_device` 结构中放置一个指向你的 `ethtool_ops` 结构的指针。应该使用在 `<linux/netdevice.h>` 中定义的宏 `SET_ETHTOOL_OPS` 来实现这个目的。请注意，即使接口关闭，你的 ethtool 方法也可以被调用。



### 17.15.3. netpoll
“Netpoll”是相对较晚（2.6.5）添加到网络堆栈的功能；其目的是在完整的网络和I/O子系统可能不可用的情况下，使内核能够发送和接收数据包。它被用于远程网络控制台和远程内核调试等功能。在你的驱动程序中支持 netpoll 并不是必要的，但在某些情况下，它可能会使你的设备更有用。在大多数情况下，支持 netpoll 也相对容易。

实现 netpoll 的驱动程序应该实现 `poll_controller` 方法。它的工作是在设备中断缺失的情况下，跟上控制器上可能发生的任何事情。几乎所有的 `poll_controller` 方法都采取以下形式：
```c
void my_poll_controller(struct net_device *dev)

{

    disable_device_interrupts(dev);

    call_interrupt_handler(dev->irq, dev, NULL);

    reenable_device_interrupts(dev);

}
```
本质上，`poll_controller` 方法只是模拟来自给定设备的中断。



## 17.16. 快速参考

本节提供了本章中介绍的概念的参考. 也解释了每个驱动需要包含的头文件的角色. 在 net_device 和 sk_buff 结构中成员的列表, 但是, 这里没有重复.

```
#include <linux/netdevice.h>

```

定义 struct net_device 和 struct net_device_stats 的头文件, 包含了几个其他网络驱动需要的头文件.

```
struct net_device *alloc_netdev(int sizeof_priv, char *name, void (*setup)(struct net_device *);
struct net_device *alloc_etherdev(int sizeof_priv);
void free_netdev(struct net_device *dev);
```

分配和释放 net_device 结构的函数

```
int register_netdev(struct net_device *dev);
void unregister_netdev(struct net_device *dev);
```

注册和注销一个网络设备.

```
void *netdev_priv(struct net_device *dev);

```

获取网络设备结构的驱动私有区域的指针的函数.

```
struct net_device_stats;

```

持有设备统计的结构.

```
netif_start_queue(struct net_device *dev);
netif_stop_queue(struct net_device *dev);
netif_wake_queue(struct net_device *dev);
```

控制传送给驱动来发送的报文的函数. 没有报文被传送, 直到 netif_start_queue 被调用. netif_stop_queue 挂起发送, netif_wake_queue 重启队列并刺探网络层重启发送报文.

```
skb_shinfo(struct sk_buff *skb);

```

宏定义, 提供对报文缓存的"shared info"部分的存取.

```
void netif_rx(struct sk_buff *skb);

```

调用来通知内核一个报文已经收到并且封装到一个 socket 缓存中的函数.

```
void netif_rx_schedule(dev);

```

来告诉内核报文可用并且应当启动查询接口; 它只是被 NAPI 兼容的驱动使用.

```
int netif_receive_skb(struct sk_buff *skb);
void netif_rx_complete(struct net_device *dev);
```

应当只被 NAPI 兼容的驱动使用. netif_receive_skb 是对于 netif_rx 的 NAPI 对等函数; 它递交一个报文给内核. 当一个 NAPI 兼容的驱动已耗尽接收报文的供应, 它应当重开中断, 并且调用 netif_rx_complete 来停止查询.

```
#include <linux/if.h>

```

由 netdevice.h 包含, 这个文件声明接口标志( IFF_ 宏定义 )和 struct ifmap, 它在网络驱动的 ioctl 实现中有重要地位.

```
void netif_carrier_off(struct net_device *dev);
void netif_carrier_on(struct net_device *dev);
int netif_carrier_ok(struct net_device *dev);
```

前 2 个函数可用来告知内核是否接口上有载波信号. netif_carrier_ok 测试载波状态, 如同在设备结构中反映的.

```
#include <linux/if_ether.h>
ETH_ALENETH_P_IPstruct ethhdr;
```

由 netdevice.h 包含, if_ether.h 定义所有的 ETH_ 宏定义, 用来代表字节长度( 例如地址长度 )以及网络协议(例如 IP). 它也定义 ethhdr 结构.

```
#include <linux/skbuff.h>

```

struct sk_buff 和相关结构的定义, 以及几个操作缓存的内联函数. 这个头文件由 netdevice.h 包含.

```
struct sk_buff *alloc_skb(unsigned int len, int priority);
struct sk_buff *dev_alloc_skb(unsigned int len);
void kfree_skb(struct sk_buff *skb);
void dev_kfree_skb(struct sk_buff *skb);
void dev_kfree_skb_irq(struct sk_buff *skb);
void dev_kfree_skb_any(struct sk_buff *skb);
```

处理 socket 缓存的分配和释放的函数. 通常驱动应当使用 dev_ 变体, 其意图就是此目的.

```
unsigned char *skb_put(struct sk_buff *skb, int len);
unsigned char *__skb_put(struct sk_buff *skb, int len);
unsigned char *skb_push(struct sk_buff *skb, int len);
unsigned char *__skb_push(struct sk_buff *skb, int len);
```

添加数据到一个 skb 的函数; skb_put 在 skb 的尾部放置数据, 而 skb_push 放在开始. 正常版本进行检查以确保有足够的空间; 双下划线版本不进行检查.

```
int skb_headroom(struct sk_buff *skb);
int skb_tailroom(struct sk_buff *skb);
void skb_reserve(struct sk_buff *skb, int len);
```

进行 skb 中的空间管理的函数. skb_headroom 和 skb_tailroom 说明在开始和结尾分别有多少空间可用. skb_reserve 可用来保留空间, 在一个必须为空的 skb 开始.

```
unsigned char *skb_pull(struct sk_buff *skb, int len);

```

skb_pull "去除" 数据从一个 skb, 通过调整内部指针.

```
int skb_is_nonlinear(struct sk_buff *skb);

```

如果这个 skb 是为发散/汇聚 I/O 分隔为几个片, 函数返回一个真值.

```
int skb_headlen(struct sk_buff *skb);

```

返回 skb 的第一个片的长度, 由 skb->data 指向.

```
void *kmap_skb_frag(skb_frag_t *frag);
void kunmap_skb_frag(void *vaddr);
```

提供对非线性 skb 中的片直接存取的函数.

```
#include <linux/etherdevice.h>
void ether_setup(struct net_device *dev);
```

为以太网驱动设置大部分方法为通用实现的函数. 它还设置 dev->flags 和安排下一个可用的 ethx 给 dev->name, 如果名子的第一个字符是一个空格或者 NULL 字符.

```
unsigned short eth_type_trans(struct sk_buff *skb, struct net_device *dev);

```

当一个以太网接口收到一个报文, 这个函数被调用来设置 skb->pkt_type. 返回值是一个协议号, 通常存储于 skb->protocol.

```
#include <linux/sockios.h>
SIOCDEVPRIVATE 
```

前 16 个 ioctl 命令, 每个驱动可为它们自己的私有用途而实现. 所有的网络 ioctl 命令都在 sockios.h 中定义.

```
#include <linux/mii.h>
struct mii_if_info;
```

声明和一个结构, 支持实现 MII 标准的设备的驱动.

```
#include <linux/ethtool.h>
struct ethtool_ops;
```

声明和结构, 使得设备与 ethtool 工具一起工作.



